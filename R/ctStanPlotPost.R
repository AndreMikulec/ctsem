#' ctStanPlotPost
#'
#' Plots prior and posterior distributions of model parameters in a ctStanModel or ctStanFit object.
#' 
#' @param obj fit or model object as generated by \code{\link{ctStanFit}},
#' \code{\link{ctModel}}, or \code{\link{ctStanModel}}.
#' @param rows vector of integers denoting which rows of ctstanmodel$pars to plot priors for. 
#' Character string 'all' plots all rows with parameters to be estimated. 
#' @param priorwidth if TRUE, plots will be scaled to show bulk of both the prior 
#' and posterior distributions. If FALSE, scale is based only on the posterior.
#' @param mfrow 2 dimensional integer vector defining number of rows and columns of plots,
#' as per the mfrow argument to \code{\link[graphics]{par}}.
#' 'auto' determines automatically, to a maximum of 4 by 4, while \code{NULL} 
#' uses the current system setting.
#' @param lwd line width for plotting.
#' @param parcontrol parameters to pass to \code{\link[graphics]{par}} which temporarily
#' change plot settings.
#' @param wait If true, user is prompted to continue before plotting next graph.  
#' If false, graphs are plotted one after another without waiting.
#' @examples
#' ctStanPlotPost(ctstantestfit)
#' @export

ctStanPlotPost<-function(obj, rows='all', priorwidth=TRUE, mfrow='auto',lwd=2,
  parcontrol=list(mgp=c(1.3,.5,0),mar=c(3,2,2,1)+.2),wait=FALSE){
  
  if(!(class(obj) %in% c('ctStanFit','ctStanModel'))) stop('not a ctStanFit or ctStanModel object!')
  
  densiter <- 1e6
  ctspec <- obj$ctstanmodel$pars
  
  paroriginal<-graphics::par()[c('mfrow','mgp','mar')]
  
  do.call(graphics::par,parcontrol)
  
  s<-extract.ctStanFit(obj)
  
  if(rows[1]=='all') rows<-(1:nrow(obj$data$popsetup)) else rows <-  
    which(rownames(obj$data$popsetup) %in% ctspec$param[rows])
  
  if(all(mfrow=='auto')) {
    mfrow <- grDevices::n2mfrow( (length(rows)+sum(obj$pars$indvarying[rows])*2))
    mfrow[mfrow > 3] <- 3
  }
  graphics::par(mfrow=mfrow)
  
  
  # snames<-names(s)
  # hmeannames<-snames[grep('hmean_',snames)]
  # hsdnames<-snames[grep('hsd_',snames)]
  # tipnames<-snames[grep('tipred_',snames)]
  # sum<-getMethod('summary','stanfit')(obj$stanfit)
  # sumnames<-dimnames(sum$summary)[[1]]
  nsubjects<-obj$data$nsubjects 
  # max(  as.numeric(unlist(lapply(grep('^indparams[[]',sumnames),function(x){
  # strsplit(gsub("[^0-9,]", "", sumnames[x]), ",")[[1]][1]
  # }))))
  # if(nsubjects < 1) nsubjects<-1
  
  
  indvaryingcount<-0
  popmeancount<-0
  
  for(ri in rows){
    
    # popmeancount <- which(obj$pars$param[is.na(obj$pars$value)] %in% obj$pars$param[ri])
    pname <- rownames(obj$data$popsetup[ri,,drop=FALSE])
    rawpopmeans<- s$rawpopmeans[,ri]
    param<-rawpopmeans
    mi <- match(pname,table = ctspec$param)
    rawpopmeanspost<-tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
    # , eval(parse(text=paste0(obj$pars$transform[ri])))
    # drawpopmeanspost<-ctDensity(rawpopmeanspost)
    
    # p$xlim=drawpopmeanspost$xlim
    # p$ylim=c(0,drawpopmeanspost$ylim[2])
    # p$x = drawpopmeanspost$density
    
    param<-stats::rnorm(densiter,0,1)
    meanprior <- tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
    # dmeanprior<-ctDensity(meanprior,bw=drawpopmeanspost$density$bw)
    
    # if(!dopost){
    #   p$x = NA
    #   p$xlim = dmeanprior$xlim
    #   p$ylim=dmeanprior$ylim
    # }
    
    
    # do.call(graphics::plot,p) 
    
    # meanprior <- meanprior[meanprior > dsubjectprior$xlim[1]-5 & meanprior < dsubjectprior$xlim[2] + 5]
    leg <- c('Pop. mean posterior','Pop. mean prior') 
    legcol <- c('black','blue') 
    
    ctDensityList(list(rawpopmeanspost,meanprior),main=paste0('Pop. mean ',pname),
      xlimsindex=if(priorwidth) 1:2 else 1,
      xaxs='i',  yaxs='i', plot=TRUE,legend=leg,colvec=legcol,lwd=lwd)
    
    # graphics::points(dmeanprior$density,col=ifelse(dopost,'blue','black'),type='l',lty=ifelse(dopost,2,1),lwd=2)
    # graphics::legend('topright',leg,
    #   text.col=legcol,bty='n')
    
    
    if(obj$data$popsetup[ri,'indvarying']==1){ #then also plot sd and subject level pars
      
      indvaryingcount<-indvaryingcount+1 #which(obj$pars$param[is.na(obj$pars$value) & obj$pars$indvarying] %in% obj$pars$param[ri])
      
      sdscale <- obj$data$popvalues[ri,'sdscale']
      sdtform <- gsub('.*', '*',obj$ctstanmodel$rawpopsdtransform,fixed=TRUE)
      
      rawpopsdbase<-s$rawpopsdbase[,indvaryingcount] 
      
      rawpopsd <- eval(parse(text=sdtform))  #rawpopsd samples
      
      param<-stats::rnorm(densiter,rawpopmeans,rawpopsd)
      subjectprior<-tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
      # dsubjectprior<-ctDensity(subjectprior)
      
      if(!obj$data$ukfpop) {
        rawindparams<-s$baseindparams[,seq(indvaryingcount,by=obj$data$nindvarying,length.out=obj$data$nsubjects)]
        param<-stats::rnorm(densiter,0,1)
        param<-rawindparams
        indparams<-tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
        # dindparams<-ctDensity(indparams,bw=dsubjectprior$density$bw)
        
        
        # graphics::plot(dindparams$density,xlab='Value',main=obj$pars$param[ri],lwd=2,yaxs='i',
        #   ylim=c(0,max(dsubjectprior$ylim[2],dindparams$ylim[2])),
        #   xlim=c(min(dsubjectprior$xlim[1],dindparams$xlim[1]),max(dsubjectprior$xlim[2],dindparams$xlim[2])))
        # graphics::points(dsubjectprior$density,col='red',lwd=2,lty=2,type='l')
        # graphics::points(dmeanprior$density,lwd=2,type='l',col='blue',lty=3)
        # graphics::legend('topright',c('Subject param posterior','Subject param prior','Pop mean prior'),
        #   text.col=c('black','red','blue'),bty='n')
        ctDensityList(list(indparams,subjectprior,meanprior),main=pname,
          colvec=c('black','red','blue'),plot=TRUE,lwd=lwd,xlimsindex=1:2,
          xaxs='i',  yaxs='i',legend=c('Subject param posterior','Subject param prior','Pop mean prior'))
      } else {
        ctDensityList(list(subjectprior,meanprior),main=pname,
          colvec=c('red','blue'),plot=TRUE,lwd=lwd,xlimsindex=1,
          xaxs='i',  yaxs='i',legend=c('Subject param prior','Pop mean prior'))
      }
      
      
      
      
      
      ### removed this plot for the moment
      # #pre-transform pop std dev
      #   p<-list(lwd=2, #plot pars
      #     x=NA,
      #     xaxs='i',
      #     yaxs='i',
      #     xlab='Value', 
      #     main=paste0('Pre-tform pop. sd ',obj$pars$param[ri])) 
      #   
      #posterior sd
      
      # if(dopost) {
      #   # drawpopsdpost<-ctDensity(rawpopsd)
      #   p$xlim=c(0, quantile(rawpopsd,probs=.98))
      #   bw = p$xlim[2] / 100# drawpopsdpost$xlim[2])
      #   drawpopsdpost<-density(rawpopsd,bw=bw,from= 0 - bw*3, to = p$xlim[2] + bw * 10)
      #   p$ylim=c(0,max(drawpopsdpost$y))
      #   p$x=drawpopsdpost$x
      #   p$y = drawpopsdpost$y
      # }
      #prior
      rawpopsdbase<-  stats::rnorm(densiter,0,1)
      rawpopsdprior <- eval(parse(text=sdtform)) #rawpopsd prior samples
      # drawpopsdprior<-ctDensity(rawpopsdprior)
      
      
      #post-transform pop std dev
      # p<-list(lwd=2, #plot pars
      #   x=NA,
      #   xaxs='i',
      #   yaxs='i',
      #   xlab='Par. value',
      #   type='l',
      #   ylab='Density',
      #   main=paste0('Pop. sd ',obj$pars$param[ri])) 
      
      #posterior
      
      hsdpost <- s[['popsd']][,ri]
      # dhsdpost<-ctDensity(hsdpost)
      # 
      # p$x = dhsdpost$density
      # p$ylim=c(0,dhsdpost$ylim[2])
      # p$xlim=c(0, dhsdpost$xlim[2])
      
      # p$xlim=c(0, quantile(hsdpost,probs=.98))
      # bw = p$xlim[2] / 100# drawpopsdpost$xlim[2])
      # dhsdpost<-density(hsdpost,bw=bw,from= 0 - bw*3, to = p$xlim[2] + bw * 10)
      # p$ylim=c(0,max(dhsdpost$y))
      # p$x=dhsdpost$x
      # p$y = dhsdpost$y
      
      param<-suppressWarnings(rawpopmeans+rawpopsdprior)
      high<-tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
      param<-suppressWarnings(rawpopmeans-rawpopsdprior)
      low<-tform(param,ctspec$transform[mi],ctspec$multiplier[mi], ctspec$meanscale[mi],ctspec$offset[mi])
      hsdprior<-abs(high - low)/2
      
      # dhsdprior<-density(hsdprior,from=0-bw*3,to=p$xlim[2]+bw*5,bw=bw)
      
      # if(!dopost) {
      #   p$xlim=c(0,dhsdprior$xlim[2])
      #   p$ylim=c(0,dhsdprior$ylim[2])
      # }
      
      
      # do.call(graphics::plot,p)
      # graphics::points(dhsdprior$x,dhsdprior$y,col=ifelse(dopost,'blue','black'),type='l',lty=ifelse(dopost,2,1),lwd=2)
      
      leg <- c('Pop. sd posterior','Pop. sd prior') 
      legcol <- c('black','blue')
      # 
      # graphics::legend('topright',leg, text.col=legcol, bty='n')
      
      ctDensityList(list(hsdpost, hsdprior),main=paste0('Pop. sd ',pname),
        xlimsindex=1,
        xaxs='i',yaxs='i',plot = TRUE, colvec=legcol, legend=leg,lwd=lwd)
      
      
      
      
      # pmeans[,indvaryingcount]<-sum$summary[sumnames %in% 
      #     paste0(obj$pars$matrix[ri],'[',1:nsubjects,',',obj$pars$row[ri],
      #       if(!(obj$pars$matrix[ri] %in% c('T0MEANS','CINT','MANIFESTMEANS'))) paste0(',',obj$pars$col[ri]),']'),
      #   1]
      # 
      # pnames[indvaryingcount]<-paste0(obj$pars$matrix[ri],'[',obj$pars$row[ri],',',obj$pars$col[ri],']')
      
      
      if(wait==TRUE & ri != utils::tail(rows,1)){
        message("Press [enter] to display next plot")
        readline()
      }
    }
  }
  
  # if(length(rows)>1){
  #   require(lattice)
  #   colnames(pmeans)<-pnames
  #   splom(pmeans,
  #     upper.panel=function(x,y) panel.loess(x, y),
  #     diag.panel = function(x,...){
  #       yrng <- current.panel.limits()$ylim
  #       d <- density(x, na.rm=TRUE)
  #       d$y <- with(d, yrng[1] + 0.95 * diff(yrng) * y / max(y) )
  #       panel.lines(d)
  #       diag.panel.splom(x,...)
  #     },
  #     lower.panel = function(x, y, i,j){
  #       panel.splom(x,y,col=rgb(0,0,1,alpha=.2),pch=16)
  #       
  #       if( j==1)  panel.axis(side=c('left'),outside=T,
  #         at=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3),tck=1,
  #         labels=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3))
  #       
  #       if( i==ncol(pmeans))  panel.axis(side=c('bottom'),outside=T,
  #         at=round(seq(max(x),min(x),length.out=5)[c(-1,-5)],digits=3),tck=1,
  #         labels=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3))
  #     },
  #     pscales=0,
  #     as.matrix = TRUE,
  #     varname.cex=.4,
  #     strip=T,
  #     main='Subject level parameter plots',
  #     xlab=NULL,ylab=NULL,
  #     col=rgb(0,0,1,alpha=.2),pch=16
  #   )
  # }
  
  do.call(graphics::par,paroriginal)
  
}

