#' ctStanPlotPost
#'
#' Plots posterior of subject level parameters for free model parameters in a \code{\link{ctStanModel}} resulting from the specified transformations.
#' 
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} using one of the Stan type arguments.
#' @param ctstanfitobj fit object as generated by \code{\link{ctStanFit}}.
#' @param rows vector of integers denoting which rows of ctstanmodelobj$parameters to plot priors for. 
#' Character string 'all' plots all rows with parameters to be estimated.
#' @param wait If true, user is prompted to continue before plotting next graph.  If false, graphs are plotted one after another without waiting.
#' @export

ctStanPlotPost<-function(ctstanmodelobj,ctstanfitobj, rows='all',wait=TRUE){

  s<-extract(ctstanfitobj)
  m<-ctstanmodelobj$parameters
  if(rows=='all') rows<-1:nrow(m)
snames<-names(s)
hmeannames<-snames[grep('output_hmean_',snames)]
hsdnames<-snames[grep('output_hsd_',snames)]
tipnames<-snames[grep('output_tip_',snames)]
sum<-getMethod('summary','stanfit')(ctstanfitobj)
sumnames<-dimnames(sum$summary)[[1]]
nsubjects<-max(  as.numeric(unlist(lapply(grep('^indparams[[]',sumnames),function(x){
  strsplit(gsub("[^0-9,]", "", sumnames[x]), ",")[1]
  }))))


  n<-500000
  indvaryingcount<-0
  hypermeancount<-0
  pmeans<-matrix(NA,nrow=nsubjects,ncol=sum(m$indvarying))
  pnames<-rep(NA,sum(m$indvarying))
  for(rowi in rows){
    if(is.na(m$value[rowi])){
      hypermeancount <- hypermeancount +1
      if(m$indvarying[rowi]){
        param<-rnorm(n)
      indvaryingcount<-indvaryingcount+1
      hypermean<- s$hypermeans[,hypermeancount]
      hypersd<-s$hypersd[,indvaryingcount]
      if(m$matrix[rowi] %in% c('T0MEANS','CINT','MANIFESTMEANS')) {
        plot(density(s[[paste0(m$matrix[rowi])]][,,m$row[rowi]]),bw=.02,xlab='Value',main=m$param[rowi],lwd=2)
      } else
      { 
        plot(density(s[[paste0(m$matrix[rowi])]][,,m$row[rowi],m$col[rowi]]),main=m$param[rowi],lwd=2)
      }
      param<-rnorm(n,hypermean,hypersd)
      points(density(eval(parse(text=paste0(m$transform[rowi]))),bw=.02,n=5000),col='red',lwd=2,lty=2,type='l')
      param<-rnorm(n,0,1)
      points(density(eval(parse(text=paste0(m$transform[rowi]))),bw=.02,n=5000),lwd=2,type='l',col='blue')
      legend('topright',c('Subject param posterior','Subject param prior','Pop mean prior'),
        text.col=c('black','red','blue'),bty='n')
      
      
      pmeans[,indvaryingcount]<-sum$summary[sumnames %in% paste0(m$matrix[rowi],'[',1:nsubjects,',',m$row[rowi],
        if(!(m$matrix[rowi] %in% c('T0MEANS','CINT','MANIFESTMEANS'))) paste0(',',m$col[rowi]),']'),1]
      
      pnames[indvaryingcount]<-paste0(m$matrix[rowi],'[',m$row[rowi],',',m$col[rowi],']')
      
      if(wait==TRUE & rowi != tail(rows,1)){
        message("Press [enter] to display next plot")
        readline()
      }
      }
    }
  }
  
  if(length(rows)>1){
  require(lattice)
  colnames(pmeans)<-pnames
  splom(pmeans,
    upper.panel=function(x,y) panel.loess(x, y),
    diag.panel = function(x,...){
      yrng <- current.panel.limits()$ylim
      d <- density(x, na.rm=TRUE)
      d$y <- with(d, yrng[1] + 0.95 * diff(yrng) * y / max(y) )
      panel.lines(d)
      diag.panel.splom(x,...)
    },
    lower.panel = function(x, y, i,j){
      panel.splom(x,y,col=rgb(0,0,1,alpha=.2),pch=16)
      
      if( j==1)  panel.axis(side=c('left'),outside=T,
        at=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3),tck=1,
        labels=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3))
      
      if( i==ncol(pmeans))  panel.axis(side=c('bottom'),outside=T,
        at=round(seq(max(x),min(x),length.out=5)[c(-1,-5)],digits=3),tck=1,
        labels=round(seq(max(y),min(y),length.out=5)[c(-1,-5)],digits=3))
    },
    pscales=0,
    as.matrix = TRUE,
    varname.cex=.4,
    strip=T,
    main='Subject level parameter plots',
    xlab=NULL,ylab=NULL,
    col=rgb(0,0,1,alpha=.2),pch=16
  )
  }
  
  
  
  
  }
  
