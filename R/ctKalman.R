#' ctStanKalman
#'
#' Takes list containing ctsem subject matrices, as well as long form data object, and calculates 
#' predicted and updated latent states, likelihoods, and predicted observations using the Kalman filter.
#' 
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} using type='stanct' or 'standt'.
#' @param kalmanpars list object containing DRIFT,T0VAR,DIFFUSION,CINT,T0MEANS,TDPREDEFFECT,
#' MANIFESTMEANS, LAMBDA, and MANIFESTVAR matrices, with list elements named accordingly. A ctsem model of type 'omx',
#' fulfills these requirements, so long as full covariance matrices are specified instead of lower triangular.
#' @param datalong long format data object containing as used by \code{\link{ctStanFit}}.
#' @param subject integer denoting which subjects data to use. 
#' 
#' @return Returns a list containing matrix objects etaprior, yprior, prederror, etapost, y, loglik,  with values for each time point in each row. 
#' Covariance matrices etapriorcov, ypriorcov, etapostcov, are returned in a sublist containing matrices for each time point.
#' @export

ctKalman<-function(ctstanmodelobj,kalmanpars,datalong,subject){

m<-ctstanmodelobj
kp<-kalmanpars

dlong<-datalong[which(datalong[,m$subjectIDname]==subject),,drop=FALSE]


Y<-dlong[,m$manifestNames,drop=FALSE]
dt<-dlong[,m$timeName,drop=FALSE]
if(m$n.TDpred > 0) {
  tdpreds<-dlong[,m$TDpredNames,drop=FALSE]
if(any(is.na(tdpreds))) stop('missingness in time dependent predictors! ctKalman cannot run.')
}

if(m$continuoustime) {
 DRIFTHATCH <- (kp$DRIFT %x% diag(m$n.latent) + diag(m$n.latent) %x% kp$DRIFT) 
  asymDIFFUSION <- matrix(-solve(DRIFTHATCH) %*% c(kp$DIFFUSION), nrow=nrow(kp$DRIFT))
}

etaprior<-list()
etapriorcov<-list()
etapost<-list()
etapostcov<-list()
err<-list()
yprior<-list()
ypriorcov<-list()
ypost<-list()
ypostcov<-list()

etaprior[[1]]<-kp$T0MEANS
if(m$n.TDpred > 0) etaprior[[1]]<-etaprior[[1]]+kp$TDPREDEFFECT %*% t(dlong[1,m$TDpredNames,drop=FALSE])
etapriorcov[[1]]<-kp$T0VAR
loglik<-rep(0,nrow(dlong))
observed<-list()

discreteDRIFT<- list()
discreteCINT<- list()
discreteDIFFUSION <- list()

for(rowi in 1:(nrow(dlong))){
  
  # if(rowi==1 |(rowi > 0 && m$continuoustime && dt[rowi] != dt[rowi-1])){
    if(m$continuoustime){
    discreteDRIFT[[rowi]] <- OpenMx::expm(kp$DRIFT)
    discreteCINT[[rowi]] <- solve(kp$DRIFT) %*% (discreteDRIFT[[rowi]] - diag(m$n.latent)) %*% kp$CINT
    discreteDIFFUSION[[rowi]] <- asymDIFFUSION - (discreteDRIFT[[rowi]] %*% asymDIFFUSION %*% t(discreteDRIFT[[rowi]]))
    }
    if(!m$continuoustime){
      discreteDRIFT[[rowi]] <-kp$DRIFT
      discreteCINT[[rowi]]<- kp$CINT
      discreteDIFFUSION[[rowi]] <- kp$DIFFUSION
    }
  # }
if(rowi>1){
        etaprior[[rowi]] <- discreteCINT[[rowi]]  + discreteDRIFT[[rowi]] %*% etapost[[rowi-1]]
        if(m$n.TDpred > 0) etaprior[[rowi]] <- etaprior[[rowi]] + kp$TDPREDEFFECT %*% t(dlong[rowi,m$TDpredNames,drop=FALSE])
        etapriorcov[[rowi]] <-  discreteDRIFT[[rowi]] %*% etapostcov[[rowi-1]] %*% t(discreteDRIFT[[rowi]])  + discreteDIFFUSION[[rowi]] #check transpose
}

          nafilter<-!is.na(Y[rowi,])
          observed[[rowi]]<-nafilter
        
        y <- Y[rowi,,drop=FALSE][,nafilter,drop=FALSE]
        
        # // one step ahead predictive distribution of y
        yprior[[rowi]] <- kp$MANIFESTMEANS + kp$LAMBDA %*% etaprior[[rowi]]
        ypriorcov[[rowi]] <- kp$LAMBDA %*% etapriorcov[[rowi]] %*% t(kp$LAMBDA) + kp$MANIFESTVAR
        # // forecast error
        err[[rowi]]<-matrix(NA,nrow=m$n.manifest)
        err[[rowi]][nafilter] <- y - yprior[[rowi]][nafilter,drop=FALSE]
        
        #if all missing...
        if(all(!nafilter)){
          etapost[[rowi]] <- etaprior[[rowi]]
          etapostcov[[rowi]] <- etapriorcov[[rowi]]
        }
        
          #if any not missing
        if(any(nafilter)){
          
        # // Kalman gain
        invypriorcov <- solve(ypriorcov[[rowi]][nafilter,nafilter,drop=FALSE])
        K<-matrix(0,nrow=m$n.latent,ncol=m$n.manifest)
        K[,nafilter] <-  etapriorcov[[rowi]] %*%   t(kp$LAMBDA[nafilter,,drop=FALSE]) %*% invypriorcov
        
        # // posterior distribution 
        # etapost[[rowi + 1]] <- etaprior[[rowi]]
        
        etapost[[rowi]] <- etaprior[[rowi]] + K[,nafilter,drop=FALSE] %*% (err[[rowi]][nafilter,,drop=FALSE])
        
        # etapostcov[[rowi + 1]] <- etapriorcov[[rowi]]
        etapostcov[[rowi]] <- (diag(ncol(kp$LAMBDA)) - K[,nafilter,drop=FALSE] %*% kp$LAMBDA[nafilter,,drop=FALSE]) %*% etapriorcov[[rowi]]
        
   
        
        
        # // log likelihood
      
         loglik[rowi] <- - 0.5 * (nrow(kp$LAMBDA[nafilter,,drop=FALSE]) * log(2 * pi)  + 
             log(det(ypriorcov[[rowi]][nafilter,nafilter,drop=FALSE]))    + 
            t(err[[rowi]][nafilter,,drop=FALSE]) %*% invypriorcov %*% (err[[rowi]][nafilter,,drop=FALSE]))
         
         ypost[[rowi]] <- kp$MANIFESTMEANS + kp$LAMBDA %*% etapost[[rowi]]
         ypostcov[[rowi]] <- kp$LAMBDA %*% etapostcov[[rowi]] %*% t(kp$LAMBDA) + kp$MANIFESTVAR
        
        }
# }
}

etasmooth<-list()
etasmoothcov<-list()
ysmooth<-list()
ysmoothcov<-list()

for(rowi in nrow(dlong):1){
  if(rowi==nrow(dlong)) {
    etasmooth[[rowi]]<-etapost[[rowi]]
    etasmoothcov[[rowi]]<-etapostcov[[rowi]]
  } else{
  smoother<- etapostcov[[rowi]] %*% t(discreteDRIFT[[rowi+1]]) %*% #is the rowi+1 correct?
    solve(etapriorcov[[rowi+1]])
  etasmooth[[rowi]]<-etapost[[rowi]]+smoother %*% (etasmooth[[rowi+1]] - etaprior[[rowi+1]])
  etasmoothcov[[rowi]]<-etapostcov[[rowi]] + smoother %*% ( etasmoothcov[[rowi+1]] - etapriorcov[[rowi+1]])
  }
  ysmooth[[rowi]] <- kp$MANIFESTMEANS + kp$LAMBDA %*% etasmooth[[rowi]]
  ysmoothcov[[rowi]] <- kp$LAMBDA %*% etasmoothcov[[rowi]] %*% t(kp$LAMBDA) + kp$MANIFESTVAR
  
  
}

etaprior<-matrix(unlist(etaprior),byrow=T,ncol=m$n.latent)
colnames(etaprior)<-m$latentNames
etapost<-matrix(unlist(etapost),byrow=T,ncol=m$n.latent)
colnames(etapost)<-m$latentNames
yprior<-matrix(unlist(yprior),byrow=T,ncol=m$n.manifest)
colnames(yprior)<-m$manifestNames
y<-dlong[,m$manifestNames,drop=FALSE]
colnames(y)<-m$manifestNames
if(m$n.TDpred>0) {
  tdpreds<-dlong[,m$TDpredNames,drop=FALSE]
colnames(tdpreds)<-m$TDpredNames
}
err<-matrix(unlist(err),byrow=T,ncol=m$n.manifest)
colnames(err)<-m$manifestNames
ypost<-matrix(unlist(ypost),byrow=T,ncol=m$n.manifest)
colnames(ypost)<-m$manifestNames

etasmooth<-matrix(unlist(etasmooth),byrow=T,ncol=m$n.latent)
colnames(etapost)<-m$latentNames
ysmooth<-matrix(unlist(ysmooth),byrow=T,ncol=m$n.manifest)
colnames(ysmooth)<-m$manifestNames

out<-list(observed,etaprior=etaprior,etapriorcov=etapriorcov,
  etapost=etapost,etapostcov=etapostcov,loglik=loglik,
  prederror=err,y=y,yprior=yprior,ypriorcov=ypriorcov,
  if(m$n.TDpred > 0) tdpreds=tdpreds,
  ypost=ypost,ypostcov=ypostcov,
  etasmooth=etasmooth,etasmoothcov=etasmoothcov,ysmooth=ysmooth,ysmoothcov=ysmoothcov)

}


