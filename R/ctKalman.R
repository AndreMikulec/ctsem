#' ctStanKalman
#'
#' Takes list containing ctsem subject matrices, as well as long form data object, and calculates 
#' predicted and updated latent states, likelihoods, and predicted observations using the Kalman filter.
#' 
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} using type='stanct' or 'standt'.
#' @param kalmanpars list object containing DRIFT,T0VAR,DIFFUSION,CINT,T0MEANS,TDPREDEFFECT,
#' MANIFESTMEANS, LAMBDA, and MANIFESTVAR matrices, with list elements named accordingly. A ctsem model of type 'omx',
#' fulfills these requirements.
#' @param datalong long format data object containing as used by \code{\link{ctStanFit}}.
#' @param subject integer denoting which subjects data to use. 
#' @export

ctKalman<-function(ctstanmodelobj,kalmanpars,datalong,subject){

m<-ctstanmodelobj
kp<-kalmanpars

dlong<-datalong[which(datalong[,m$subjectIDname]==subject),]

Y<-dlong[,m$manifestNames]
dt<-dlong[,m$timeName]
if(m$n.TDpred > 0) tdpreds<-dlong[,m$TDpredNames]

if(m$continuoustime) {
 DRIFTHATCH <- (kp$DRIFT %x% diag(m$n.latent) + diag(m$n.latent) %x% kp$DRIFT) 
  asymDIFFUSION <- matrix(-solve(DRIFTHATCH) %*% c(kp$DIFFUSION), nrow=nrow(kp$DRIFT))
}

etaprior<-list()
etapriorcov<-list()
etapost<-list()
etapostcov<-list()
err<-list()
ypred<-list()
ypredcov<-list()

etapost[[1]]<-kp$T0MEANS
etapostcov[[1]]<-kp$T0VAR
loglik<-rep(NA,nrow(dlong))

for(rowi in 1:nrow(dlong)){
  
  if(rowi==1 |(rowi > 0 && m$continuoustime && dt[rowi] != dt[rowi-1])){
    if(m$continuoustime){
    discreteDRIFT <- OpenMx::expm(kp$DRIFT)
    discreteCINT <- solve(kp$DRIFT) %*% (discreteDRIFT - diag(m$n.latent)) %*% kp$CINT
    discreteDIFFUSION <- asymDIFFUSION - (discreteDRIFT %*% asymDIFFUSION %*% t(discreteDRIFT))
    }
    if(!m$continuoustime){
      discreteDRIFT <-kp$DRIFT
      discreteCINT<- kp$CINT
      discreteDIFFUSION <- kp$DIFFUSION
    }
  }

        etaprior[[rowi]] <- discreteCINT  + discreteDRIFT %*% etapost[[rowi]]
        etapriorcov[[rowi]] <-  discreteDRIFT %*% etapostcov[[rowi]] %*% t(discreteDRIFT)  + discreteDIFFUSION #check transpose

        
        ##if all missing
        # if (all(is.na(Y[rowi,]))) {
        #   etapost[[rowi + 1]] <- etaprior[[rowi]]
        #   etapostcov[[rowi + 1]] <- etapriorcov[[rowi]]
          
        # } else { # if some observations create right size matrices for missingness and calculate...
          # vector[nobsi] Y_filt;
          # matrix[nobsi, nlatent] LAMBDA_filt;
          # vector[nobsi] MANIFESTMEANS_filt;
          # matrix[nobsi, nobsi] MANIFESTVAR_filt;
          # vector[nobsi] Ypred_filt;      
          # matrix[nobsi, nobsi] Ypredcov_filt;
          # vector[nobsi] err;
          # matrix[nlatent, nobsi] K_filt; // kalman gain
          # matrix[nobsi, nobsi] invYpredcov_filt;
          # matrix[nobsi, nobsi] invYpredcov_filt_chol;
          
          # for(obsi in 1:nobsi){ // for non missing observations in this row
          #   Y_filt[[obsi]] <- Y[rowi][whichobs_y[rowi][obsi]]; // filter the data
          #   MANIFESTMEANS_filt[obsi] = MANIFESTMEANS[subjecti][whichobs_y[rowi][obsi]]; // and manifest means
          #   LAMBDA_filt[obsi] = LAMBDA[subjecti][whichobs_y[rowi][obsi]]; // and loading matrix
          #   for(obsj in 1:nobsi){
          #     MANIFESTVAR_filt[obsi,obsj] = MANIFESTVAR[subjecti][whichobs_y[rowi][obsi], whichobs_y[rowi][obsj]]; // and manifest variance
          #   }
          # }
        
          nafilter<-!is.na(Y[rowi,])
        
        y <- Y[rowi,][nafilter,drop=FALSE]
        
        
        # // one step ahead predictive distribution of y
        ypred[[rowi]] <- kp$MANIFESTMEANS + kp$LAMBDA %*% etaprior[[rowi]]
        
        ypredcov[[rowi]] <- kp$LAMBDA %*% etapriorcov[[rowi]] %*% t(kp$LAMBDA) + kp$MANIFESTVAR
        
        # // forecast error
        err[[rowi]] <- y - ypred[[rowi]][nafilter,drop=FALSE]
        
        # // Kalman gain
        invypredcov <- solve(ypredcov[[rowi]])
        K <-  etapriorcov[[rowi]] %*%   t(kp$LAMBDA) %*% invypredcov
        
        # // posterior distribution 
        etapost[[rowi + 1]] <- etaprior[[rowi]]
        etapost[[rowi + 1]][nafilter,] <- etaprior[[rowi]][nafilter,] + K[nafilter,nafilter,drop=FALSE] %*% err[[rowi]]
        
        # etapostcov[[rowi + 1]] <- etapriorcov[[rowi]]
        etapostcov[[rowi + 1]] <- ((diag(nrow(kp$LAMBDA)) - K %*% kp$LAMBDA) %*% etapriorcov[[rowi]])
        
   
        
        
        # // log likelihood
        loglik[rowi] <- - 0.5 * (nrow(kp$LAMBDA[nafilter,,drop=FALSE]) * log(2 * 22/7)  + log(det(ypredcov[[rowi]]))    + 
            t(err[[rowi]]) %*% invypredcov[nafilter,nafilter,drop=FALSE] %*% (err[[rowi]]))
# }
}

out<-list(etaprior=etaprior,etapriorcov=etapriorcov,
  etapost=etapost,etapostcov=etapostcov,loglik=loglik,
  err=err,ypred=ypred,ypredcov=ypredcov)

}


