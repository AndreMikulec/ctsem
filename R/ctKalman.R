#' ctStanKalman
#'
#' Takes list containing ctsem subject matrices, as well as long form data object, and calculates 
#' predicted and updated latent states, likelihoods, and predicted observations using the Kalman filter.
#' 
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} using type='stanct' or 'standt'.
#' @param kalmanpars list object containing DRIFT,T0VAR,DIFFUSION,CINT,T0MEANS,TDPREDEFFECT,
#' MANIFESTMEANS, LAMBDA, and MANIFESTVAR matrices, with list elements named accordingly. A ctsem model of type 'omx',
#' fulfills these requirements, so long as full covariance matrices are specified instead of lower triangular.
#' @param datalong long format data object containing as used by \code{\link{ctStanFit}}.
#' @param subject integer denoting which subjects data to use. 
#' 
#' @value Returns a list containing matrix objects etaprior, ypred, prederror, etapost, y, loglik,  with values for each time point in each row. 
#' Covariance matrices etapriorcov, ypredcov, etapostcov, are returned in a sublist containing matrices for each time point.
#' @export

ctKalman<-function(ctstanmodelobj,kalmanpars,datalong,subject){

m<-ctstanmodelobj
kp<-kalmanpars

dlong<-datalong[which(datalong[,m$subjectIDname]==subject),,drop=FALSE]

Y<-dlong[,m$manifestNames,drop=FALSE]
dt<-dlong[,m$timeName,drop=FALSE]
if(m$n.TDpred > 0) {
  tdpreds<-dlong[,m$TDpredNames,drop=FALSE]
if(any(is.na(tdpreds))) stop('missingness in time dependent predictors! ctKalman cannot run.')
}

if(m$continuoustime) {
 DRIFTHATCH <- (kp$DRIFT %x% diag(m$n.latent) + diag(m$n.latent) %x% kp$DRIFT) 
  asymDIFFUSION <- matrix(-solve(DRIFTHATCH) %*% c(kp$DIFFUSION), nrow=nrow(kp$DRIFT))
}

etaprior<-list()
etapriorcov<-list()
etapost<-list()
etapostcov<-list()
err<-list()
ypred<-list()
ypredcov<-list()

etaprior[[1]]<-kp$T0MEANS
if(m$n.TDpred > 0) etaprior[[1]]<-etaprior[[1]]+kp$TDPREDEFFECT %*% t(dlong[rowi,m$TDpredNames,drop=FALSE])
etapriorcov[[1]]<-kp$T0VAR
loglik<-rep(0,nrow(dlong))
observed<-list()

for(rowi in 1:(nrow(dlong))){
  
  if(rowi==1 |(rowi > 0 && m$continuoustime && dt[rowi] != dt[rowi-1])){
    if(m$continuoustime){
    discreteDRIFT <- OpenMx::expm(kp$DRIFT)
    discreteCINT <- solve(kp$DRIFT) %*% (discreteDRIFT - diag(m$n.latent)) %*% kp$CINT
    discreteDIFFUSION <- asymDIFFUSION - (discreteDRIFT %*% asymDIFFUSION %*% t(discreteDRIFT))
    }
    if(!m$continuoustime){
      discreteDRIFT <-kp$DRIFT
      discreteCINT<- kp$CINT
      discreteDIFFUSION <- kp$DIFFUSION
    }
  }
if(rowi>1){
        etaprior[[rowi]] <- discreteCINT  + discreteDRIFT %*% etapost[[rowi-1]]
        if(m$n.TDpred > 0) etaprior[[rowi]] <- etaprior[[rowi]] + kp$TDPREDEFFECT %*% t(dlong[rowi,m$TDpredNames,drop=FALSE])
        etapriorcov[[rowi]] <-  discreteDRIFT %*% etapostcov[[rowi-1]] %*% t(discreteDRIFT)  + discreteDIFFUSION #check transpose
}

          nafilter<-!is.na(Y[rowi,])
          observed[[rowi]]<-nafilter
        
        y <- Y[rowi,,drop=FALSE][,nafilter,drop=FALSE]
        
        # // one step ahead predictive distribution of y
        ypred[[rowi]] <- kp$MANIFESTMEANS + kp$LAMBDA %*% etaprior[[rowi]]
        ypredcov[[rowi]] <- kp$LAMBDA %*% etapriorcov[[rowi]] %*% t(kp$LAMBDA) + kp$MANIFESTVAR
        # // forecast error
        err[[rowi]]<-matrix(NA,nrow=n.manifest)
        err[[rowi]][nafilter] <- y - ypred[[rowi]][nafilter,drop=FALSE]
        
        #if all missing...
        if(all(!nafilter)){
          etapost[[rowi]] <- etaprior[[rowi]]
          etapostcov[[rowi]] <- etapriorcov[[rowi]]
        }
        
          #if any not missing
        if(any(nafilter)){
          
        # // Kalman gain
        invypredcov <- solve(ypredcov[[rowi]][nafilter,nafilter,drop=FALSE])
        K<-matrix(0,nrow=m$n.latent,ncol=m$n.manifest)
        K[,nafilter] <-  etapriorcov[[rowi]] %*%   t(kp$LAMBDA[nafilter,,drop=FALSE]) %*% invypredcov
        
        # // posterior distribution 
        # etapost[[rowi + 1]] <- etaprior[[rowi]]
        
        etapost[[rowi]] <- etaprior[[rowi]] + K[,nafilter,drop=FALSE] %*% (err[[rowi]][nafilter,,drop=FALSE])
        
        # etapostcov[[rowi + 1]] <- etapriorcov[[rowi]]
        etapostcov[[rowi]] <- (diag(ncol(kp$LAMBDA)) - K[,nafilter,drop=FALSE] %*% kp$LAMBDA[nafilter,,drop=FALSE]) %*% etapriorcov[[rowi]]
        
   
        
        
        # // log likelihood
      
         loglik[rowi] <- - 0.5 * (nrow(kp$LAMBDA[nafilter,,drop=FALSE]) * log(2 * pi)  + 
             log(det(ypredcov[[rowi]][nafilter,nafilter,drop=FALSE]))    + 
            t(err[[rowi]][nafilter,,drop=FALSE]) %*% invypredcov %*% (err[[rowi]][nafilter,,drop=FALSE]))
        
        }
# }
}

etaprior<-matrix(unlist(etaprior),byrow=T,ncol=m$n.latent)
colnames(etaprior)<-m$latentNames
etapost<-matrix(unlist(etapost),byrow=T,ncol=m$n.latent)
colnames(etapost)<-m$latentNames
ypred<-matrix(unlist(ypred),byrow=T,ncol=m$n.manifest)
colnames(ypred)<-m$manifestNames
y<-dlong[,c(m$manifestNames,m$TDpredNames),drop=FALSE]
colnames(y)<-m$manifestNames
err<-matrix(unlist(err),byrow=T,ncol=m$n.manifest)
colnames(err)<-m$manifestNames

out<-list(observed,etaprior=etaprior,etapriorcov=etapriorcov,
  etapost=etapost,etapostcov=etapostcov,loglik=loglik,
  prederror=err,y=y,yypred=ypred,ypredcov=ypredcov)

}


