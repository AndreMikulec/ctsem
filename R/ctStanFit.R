#' ctStanFit
#'
#' Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
#' Stan. 
#' 
#' @param datalong long format data containing columns for subject id, manifest variables, 
#' any time dependent (i.e. varying within subject) predictors, 
#' and any time independent (not varying within subject) predictors.
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt'.
#' @param kalman logical indicating whether or not to integrate over latent states using a Kalman filter. 
#' Generally recommended to set TRUE.
#' @param densehyper logical indicating whether to estimate a prior for correlations between parameters, or fix it to 0.
#' Samples much faster if set to FALSE, but setting TRUE may improve estimation of priors for subject level parameters.
#' @param fit If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.
#' @param noncentered if FALSE, sample subject level parameters directly, if TRUE, sample subject level parameters as
#' deviations from the estimated population mean. TRUE seems to result in somewhat more effective sampling, 
#' based on limited testing.
#' @param optimize if TRUE, use Stan's optimizer for maximum a posteriori estimates. Not recommended unless
#' no parameters vary across subjects.
#' @param vb if TRUE, use Stan's variational approximation. Presently experimental and not recommended.
#' @param iter number of iterations, half of which will be devoted to warmup.
#' @param chains number of chains to sample.
#' @export
ctStanFit<-function(datalong, ctstanmodelobj, iter=1000, kalman=TRUE, densehyper=FALSE,
  fit=TRUE, plot=FALSE, noncentered=TRUE,stdnorm=FALSE,adapt_delta=.8,
  optimize=FALSE, vb=FALSE, chains=3,...){
  
  nonlinear=FALSE
  
  stanplot<-function(chains,seed){
    wd<-  paste0("setwd('",getwd(),"')")
    writeLines(text=paste0(wd,'
      seed<-',seed,';
      chains<-',chains,';
      
      notyet<-TRUE
      while(notyet==TRUE){
      Sys.sleep(10);
      samps<-try(read.csv(file=paste0(seed,"samples.csv",1),comment.char="#"))
      if(class(samps) != "try-error") notyet<-FALSE
      }
      varnames<-colnames(samps);
      require(shiny); 
      shiny::runApp(appDir=list(server=function(input, output,session) {
      
      output$chainPlot <- renderPlot({
      parameter<-input$parameter
      begin<-input$begin
      colimport<-rep("NULL",length(varnames))
      colimport[which(varnames %in% parameter)]<-NA
      begin<-input$begin
      samps<-list()
      for(chaini in 1:chains) {
      samps[[chaini]]<-read.csv(file=paste0(seed,"samples.csv",chaini),comment.char="#",colClasses = colimport)
      }
      
      mini<-min(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      maxi<-max(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      lengthi<-max(unlist(lapply(1:chains,function(chaini) length(samps[[chaini]][-1:-begin,parameter]))),na.rm=T)
      
      plot(begin:lengthi,
      c(samps[[1]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[1]][-1:-begin,parameter]))),
      type="l",xlab="",ylab="",main=parameter,
      log=ifelse(parameter %in% c("stepsize__"),"y",""),
      xlim=c(begin,lengthi),
      ylim=c(mini,maxi)
      )
      
      if(chains > 1) for(chaini in 2:chains){
      points(begin:lengthi,c(samps[[chaini]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[chaini]][-1:-begin,parameter]))),type="l",xlab="",ylab="",main=parameter,col=chaini)
      }
      grid()
      
      })
      },ui=fluidPage(
      # Application title
      titlePanel("Hello Shiny!"),
      sidebarLayout(
      # Sidebar with a slider input for number of observations
      sidebarPanel(
      sliderInput("begin", "Start of range:", min = 1,max=length(samps[,2]),value = 1,step=1), 
      selectInput("parameter", "Choose a parameter:", choices = varnames),
      actionButton("refresh", "Refresh sample data")
      ),
      
      # Show a plot of the generated distribution
      mainPanel(
      plotOutput("chainPlot")
      )
      ))),
      launch.browser=TRUE)
      quit(save="no")'),con='stanplottemp.R')
    system(paste0("Rscript.exe --slave --no-restore -e source('",getwd(),"/stanplottemp.R')"),wait=F)
    
  }
  
  #read in ctmodel values
  ctspec<-ctstanmodelobj$parameters
  
  if(kalman==FALSE) {
    message('ATTENTION: T0VAR matrix is ignored when kalman=FALSE \n')
    ctspec<-ctspec[-which(ctspec$matrix %in% 'T0VAR'),]
    if(any(!is.na(ctspec[ctspec$matrix %in% 'T0MEANS','value']))) message('ATTENTION: Some T0MEANS are fixed - may be problematic when kalman=FALSE \n')
  }
  
  n.latent<-ctstanmodelobj$n.latent
  n.manifest<-ctstanmodelobj$n.manifest
  n.TDpred<-ctstanmodelobj$n.TDpred
  n.TIpred<-ctstanmodelobj$n.TIpred
  
  manifestNames<-ctstanmodelobj$manifestNames
  latentNames<-ctstanmodelobj$latentNames
  TDpredNames<-ctstanmodelobj$TDpredNames
  TIpredNames<-ctstanmodelobj$TIpredNames
  id<-ctstanmodelobj$subjectIDname
  timeName<-ctstanmodelobj$timeName
  continuoustime<-ctstanmodelobj$continuoustime
  indvarying<-ctspec$indvarying
  nindvarying<-sum(indvarying)
  nparams<-sum(is.na(ctspec$value))
  
 
  #data checks
  if(any(is.na(as.numeric(datalong[,id])))) stop('id column may not contain NA\'s or character strings!')
  
  
  T0check<-1
  for(i in 2:nrow(datalong)){
    T0check<-c(T0check, ifelse(datalong[,'id'][i] != datalong[,'id'][i-1], 1, 0))
  }
  
  if(any(is.na(datalong[,timeName]))) stop('Missing "time" column!')
  
  #check id and calculate intervals
  oldsubi<-0
  dT<-rep(-1,length(datalong[,timeName]))
  intervalChange<-dT
  for(rowi in 1:length(datalong[,timeName])) {
    subi<-datalong[rowi,id]
    if(rowi==1 && subi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
    if(oldsubi!=subi && subi-oldsubi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
    if(continuoustime==TRUE){
      if(subi - oldsubi == 1) dT[rowi]<-0
      if(subi - oldsubi == 0) dT[rowi]<-datalong[rowi,timeName] - datalong[rowi-1,timeName]
      if(subi!=oldsubi) intervalChange[rowi] <-  0
      if(subi==oldsubi && dT[rowi] != dT[rowi-1]) intervalChange[rowi] <- 1
      if(subi==oldsubi && dT[rowi] == dT[rowi-1]) intervalChange[rowi] <- 0
    }
    oldsubi<-subi
  }
  
  
  if(n.TDpred > 0) {
    datalong[,TDpredNames][is.na(datalong[,TDpredNames])] <-0 ## temporary fix for missingness
    if(any(is.na(datalong[,TDpredNames]))) stop('Missingness in TDpreds!')
  }
  if(n.TIpred > 0) {
    if(n.TIpred > 0) tipreds <- datalong[match(unique(datalong[,id]),datalong[,id]),TIpredNames,drop=FALSE]
    if(any(is.na(tipreds))) stop('Missingness in TIpreds!')
  }
  
  datalong[is.na(datalong)]<-99999 #missing data
  
  if(n.TDpred > 0) tdpreds <- datalong[,TDpredNames,drop=FALSE]
  
  nsubjects <- length(unique(datalong[, 'id'])) 
  
  checkvarying<-function(matrixnames,yesoutput,nooutput=''){#checks if a matrix is set to individually vary in ctspec
    out<-nooutput
    if(any(ctspec$indvarying[ctspec$matrix %in% matrixnames])) out<-yesoutput
    return(out)
  }
    
  

  
  stanmodelobj <- paste0('
    functions{
    
    matrix fillcholcordiag(matrix mat){
    matrix[rows(mat),cols(mat)] out;
    real tempsum;
    out[1,1]=1;
    if(rows(mat) > 1){
    for(rowi in 2:rows(out)){
    tempsum=0;
    for(coli in 1:(rowi-1)){
    out[rowi,coli]=mat[rowi,coli];
    out[coli,rowi] = 0;
    tempsum = tempsum + mat[rowi,coli]^2;
    }
    out[rowi,rowi]=sqrt(fabs(1-tempsum));
    }
    }
    return out;
    }
    
    
    
    matrix varmatrixtransform(matrix mat){
    int ndim;
    matrix[rows(mat),cols(mat)] mscale;
    matrix[rows(mat),cols(mat)] mcholcor;
    matrix[rows(mat),cols(mat)] mchol;
    matrix[rows(mat),cols(mat)] mtx;
    ndim = cols(mat);
    for(coli in 1:ndim){
    for(rowi in 1:ndim){
    
    if(rowi==coli) {
    mscale[rowi,coli] =  mat[rowi,coli];
    }
    
    if(rowi > coli){
    mscale[rowi,coli] =0;
    mscale[coli,rowi] =0;
    mcholcor[rowi,coli] =  mat[rowi,coli]; 
    }
    }}
    mcholcor = fillcholcordiag(mcholcor);
    mchol = mscale * mcholcor;
    mtx=multiply_lower_tri_self_transpose(mchol) ;
    return mtx;
    }
    
    
    matrix expmp(matrix A, matrix padeC, vector padeCbig){
    int n;
    real nA;
    real colsum;
    int l;
    matrix[4,10] C;
    vector[4] t;
    matrix[rows(A),rows(A)] I;
    matrix[rows(A),rows(A)] P;
    matrix[rows(A),rows(A)] U;
    matrix[rows(A),rows(A)] V;
    matrix[rows(A),rows(A)] X;
    
    vector[14] Cbig;
    real s;
    real si;
    matrix[rows(A),rows(A)] B;
    matrix[rows(A),rows(A)] B2;
    matrix[rows(A),rows(A)] B4;
    matrix[rows(A),rows(A)] B6;
    matrix[rows(A),rows(A)] A2;
    
    si = 0;
    C = padeC;
    Cbig = padeCbig;
    
    n =rows(A);
    if(n != cols(A)) print("expmp: Matrix not square!")
    
    if (n <= 1) X = exp(A);
    else{
    
    // nA = Matrix::norm(A, "1")
    nA = 0;
    for(coli in 1:n){
    colsum=0;
    for(rowi in 1:n){
    colsum=colsum+fabs(A[rowi,coli]);
    }
    if(colsum > nA) nA = colsum;
    }
    
    I = diag_matrix(rep_vector(1,n));
    if (nA <= 2.1) {
    t[1] = 0.015; t[2]= 0.25; t[3]= 0.95; t[4]= 2.1;
    
    //l = which.max(nA <= t)
    for(ti in 1:4){
    if(l==0){
    if(nA <= t[ti]) l = ti;
    }
    }
    
    A2 = A * A;
    P = I;
    U = C[l, 2] * I;
    V = C[l, 1] * I;
    for (k in 1:l) {
    P = P * A2;
    U = U + C[l, (2 * k) + 2] * P;
    V = V + C[l, (2 * k) + 1] * P;
    }
    U = A * U;
    X = inverse(V - U) * (V + U);
    }
    
    else {
    s = log2(nA/5.4);
    B = A;
    if (s > 0) {
    s = ceil(s);
    B = B/(2^s);
    }
    
    B2 = B * B;
    B4 = B2 * B2;
    B6 = B2*B4;
    U = B*(B6*(Cbig[14] * B6 + Cbig[12] * B4 + Cbig[10] * B2) + Cbig[8] * B6 + Cbig[6] * B4 + Cbig[4] * B2 + Cbig[2] * I);
    V = B6*(Cbig[13] * B6 + Cbig[11] * B4 + Cbig[9] * B2) + Cbig[7] * B6 + Cbig[5] * B4 + Cbig[3] * B2 + Cbig[1] * I;
    X = inverse(V - U) * (V + U);
    
    if (s > 0) {
    while (si < s){ 
    si = si + 1;
    X = X * X;
    }
    }
    }
    
    }
    return X;
    }

vector vecsqrt(vector in) {
    vector[num_elements(in)] out;
    for (i in 1:num_elements(in)){
        out[i] = sqrt(in[i]);
    }
    return out;
}

    
    
    
    
    
    matrix kron_prod(matrix mata, matrix matb){
    int m;
    int p;
    int n;
    int q;
    matrix[rows(mata)*rows(matb),cols(mata)*cols(matb)] C;
    m=rows(mata);
    p=rows(matb);
    n=cols(mata);
    q=cols(matb);
    for (i in 1:m){
    for (j in 1:n){
    for (k in 1:p){
    for (l in 1:q){
    C[p*(i-1)+k,q*(j-1)+l] = mata[i,j]*matb[k,l];
    }
    }
    }
    }
    return C;
    }
    
    matrix makesym(matrix mat){
    matrix[rows(mat),cols(mat)] out;
    out=mat;
    for(rowi in 1:rows(mat)){
    for(coli in 1:cols(mat)){
    if(coli > rowi) out[rowi,coli]=out[coli,rowi];
    }
    }
    return out;
    }
    
    }
    data {
    matrix[4,10] padeC; // for matrix exponential
    vector[14] padeCbig;
    int<lower=0> ndatapoints;
    int<lower=1> nmanifest;
    int<lower=1> nlatent;
    int<lower=1> nsubjects;
    
    ',if(n.TIpred > 0) paste0('int<lower=0> ntipred; // number of time independent covariates
      matrix[nsubjects,ntipred] tipreds; '),'
    
    vector[nmanifest] Y[ndatapoints];
    int<lower=0> ntdpred; // number of time dependent covariates
    
    ',if(n.TDpred > 0) paste0('vector[ntdpred] tdpreds[ndatapoints];'),'
    
    vector[ndatapoints] dT; // time intervals
    int intervalChange[ndatapoints]; //logical indicating if interval changes
    int subject[ndatapoints];
    int<lower=0> nparams;
    int T0check[ndatapoints]; // logical indicating which rows are the first for each subject
    int continuoustime; // logical indicating whether to incorporate timing information
    int nindvarying; // number of subject level parameters that are varying across subjects
    ',if(nindvarying>0) paste0('int indvaryingindex',if(nindvarying>1) '[nindvarying]',';
    vector[nindvarying] sdscale;'),'
    
    int<lower = 0, upper = nmanifest> nobs_y[ndatapoints];  // number of observed variables per observation
    int<lower = 0, upper = nmanifest> whichobs_y[ndatapoints, nmanifest]; // index of which variables are observed per observation
    }
    
    transformed data{
    matrix[nlatent,nlatent] IIlatent;
    IIlatent = diag_matrix(rep_vector(1,nlatent));
    }
    
    parameters {
    
    vector[nparams] hypermeans; // subject level parameter means \n','
    
    ',if(any(indvarying)) {
      'vector[nindvarying] indparams[nsubjects]; //subject level parameters
      vector<lower=0>[nindvarying] hypersd; // population sd of any varying subject level parameters
      '},'
    
    ',if(any(indvarying) & densehyper==TRUE) 'cholesky_factor_corr[nindvarying] hypercholcorr; // cholesky correlation of varying subject parameters\n','
    
    ',if(n.TIpred > 0) paste0('vector[',sum(unlist(ctspec[,paste0(TIpredNames,'_effect')])),'] tipredeffectparams; // effects of time independent covariates\n'),'
    
    ',if(kalman==FALSE) 'vector[nlatent] eta[ndatapoints-nsubjects]; // latent states excluding initial T0 ones\n','
    
    }
    
    transformed parameters{

    ',if(any(nindvarying)) paste0('
    matrix[nindvarying,nindvarying] paramchol; //cholesky of population covariance of varying subject parameters
    ',if(stdnorm==TRUE) 'matrix[nindvarying,nindvarying] invparamchol; //just storing the inverse
    vector[nindvarying*nsubjects] indparamstrans; // transformation of subject level parameters to standard normal dist \n'),'
    
    matrix[nlatent,nlatent] DIFFUSION',checkvarying('DIFFUSION','[nsubjects]','[1]'),'; //additive latent process variance
    matrix[nlatent,nlatent] T0VAR',checkvarying('T0VAR','[nsubjects]','[1]'),'; //initial latent process variance
    matrix[nlatent,nlatent] DRIFT',checkvarying('DRIFT','[nsubjects]','[1]'),'; //dynamic relationships of processes
    ',if(continuoustime) 'matrix[nlatent,nlatent] invDRIFT',checkvarying('DRIFT','[nsubjects]','[1]'),'; \n','
    matrix[nmanifest,nmanifest] MANIFESTVAR',checkvarying('MANIFESTVAR','[nsubjects]','[1]'),'; // manifest error variance
    vector[nmanifest] MANIFESTMEANS',checkvarying('MANIFESTMEANS','[nsubjects]','[1]'),';
    vector[nlatent] T0MEANS',checkvarying('T0MEANS','[nsubjects]','[1]'),'; // initial (T0) latent states
    matrix[nmanifest,nlatent] LAMBDA',checkvarying('LAMBDA','[nsubjects]','[1]'),'; // loading matrix
    vector[nlatent] CINT',checkvarying('CINT','[nsubjects]','[1]'),'; // latent process intercept
    matrix[nlatent,nlatent] asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),'; //latent process variance as time interval goes to inf
    
    
    ',if(n.TDpred > 0) paste0('matrix[nlatent,ntdpred] TDPREDEFFECT',checkvarying('TDPREDEFFECT','[nsubjects]','[1]'),'; // effect of time dependent predictors'),'
    ',if(n.TIpred > 0) paste0('matrix[',nindvarying,',',n.TIpred,'] tipredeffect; //design matrix of individual time independent predictor effects'),'
    
    ',if(n.TIpred > 0) paste0(unlist(lapply(1,function(x){ ## collects all the time independent predictors effects into the design matrix
      count<-0
      tirow<-0
      out<-c()
      for(rowi in 1:nrow(ctspec[,])){
        if(is.na(ctspec$value[rowi]) & ctspec$indvarying[rowi]) {
          tirow<-tirow+1
          for(predi in 1:n.TIpred){
            if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == FALSE) out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = 0; \n')
            if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == TRUE) {
              count<-count+1
              out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = tipredeffectparams[',count,']; \n ')
            }
          }
        }}
      return(out)
    })),collapse=''),'


    ',if(any(ctspec$indvarying)) paste0(
      if(densehyper) 'paramchol= diag_pre_multiply(hypersd .* sdscale,hypercholcorr);\n ',
      if(!densehyper) 'paramchol=diag_matrix(hypersd .* sdscale);\n',
      if(stdnorm) 'invparamchol = inverse(paramchol);\n'),'
    
    {
    ',if(continuoustime) 'matrix[nlatent*nlatent,nlatent*nlatent] DRIFTHATCH',checkvarying(c('DRIFT'),'[nsubjects]','[1]'),';  \n','
    vector[nlatent*nlatent] asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),';
    
    ',if(any(ctspec$indvarying) & stdnorm) paste0('
      for(subjecti in 1:nsubjects){ // transform subject parameters to standard normal dist
      indparamstrans[(1+(subjecti-1)*nindvarying):(subjecti*nindvarying)]=invparamchol * (indparams[subjecti]',
      if(n.TIpred>0) '-tipredeffect * tipreds[subjecti]\' ',
      if(!noncentered) '-hypermeans[indvaryingindex]',
      ');
      }
      '),'
    
    
     // create subject specific parameter matrices from fixed and transformed free effects 
    ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi) {
      
      x<-paste0(
        checkvarying(ctspec[rowi,'matrix'],'for(subjecti in 1:nsubjects) '),
        ctspec[rowi,'matrix'], checkvarying(ctspec[rowi,'matrix'],'[subjecti]','[1]'),'[', ctspec[rowi,'row'], 
        if(ctspec[rowi,'matrix'] %in% c('LAMBDA','DRIFT','DIFFUSION',
          'MANIFESTVAR', 'TDPREDEFFECT', 'T0VAR')) paste0(' , ', ctspec[rowi,'col']),
        ']') 
      
      y<- paste0('(',
        if(is.na(ctspec[rowi,'value']) & (noncentered | !ctspec$indvarying[rowi])) paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
        if(ctspec[rowi,'indvarying'] & noncentered) ' + ',
        if(ctspec[rowi,'indvarying']) paste0('indparams[subjecti][',which(ctspec[ctspec$indvarying,'param']==ctspec[rowi,'param']),']')
        ,')')
      
      if(!is.na(ctspec[rowi,'value'])) out<-paste0(x,' = ',ctspec[rowi,'value'],'; \n')
        
        if(!is.na(ctspec$transform[rowi]) & is.na(ctspec$value[rowi])) out<-paste0(
          x, ' = ', gsub('param',y,ctspec$transform[rowi]),'; \n')
      return(out)
    })),collapse=''),
    '
    
    
     // perform any whole matrix transformations 
    
    ',checkvarying('MANIFESTVAR','for(individual in 1:nsubjects)'),'MANIFESTVAR',checkvarying('MANIFESTVAR','[individual]','[1]'),' = varmatrixtransform(MANIFESTVAR',checkvarying('MANIFESTVAR','[individual]','[1]'),');
    ',checkvarying('DIFFUSION','for(individual in 1:nsubjects)'),'DIFFUSION',checkvarying('DIFFUSION','[individual]','[1]'),' = varmatrixtransform(DIFFUSION',checkvarying('DIFFUSION','[individual]','[1]'),');
    ',checkvarying('T0VAR','for(individual in 1:nsubjects)'),'T0VAR',checkvarying('T0VAR','[individual]','[1]'),' = varmatrixtransform(T0VAR',checkvarying('T0VAR','[individual]','[1]'),');
    
    ',if(continuoustime==TRUE) paste0('
      ',checkvarying('DRIFT','for(individual in 1:nsubjects)'),' invDRIFT',checkvarying('DRIFT','[individual]','[1]'),' = 
          inverse(DRIFT',checkvarying('DRIFT','[individual]','[1]'),');
      ',checkvarying('DRIFT','for(individual in 1:nsubjects)'),' DRIFTHATCH',checkvarying(c('DRIFT'),'[individual]','[1]'),' = 
          kron_prod(DRIFT',checkvarying('DRIFT','[individual]','[1]'),',diag_matrix(rep_vector(1, nlatent))) + 
          kron_prod(diag_matrix(rep_vector(1, nlatent)),DRIFT',checkvarying('DRIFT','[individual]','[1]'),');
      
      ',checkvarying(c('DIFFUSION','DRIFT'),'for(individual in 1:nsubjects){'),'
      asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),' = 
        -inverse(DRIFTHATCH',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),') * 
        to_vector(DIFFUSION',checkvarying('DIFFUSION','[individual]','[1]'),');
      for(drowi in 1:nlatent) {
      for(dcoli in 1:nlatent){
      asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),'[drowi,dcoli] = 
        asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),'[drowi+(dcoli-1)*nlatent];
      }}
      '),
    if(continuoustime==FALSE) paste0('
      ',checkvarying(c('DIFFUSION','DRIFT'),'for(individual in 1:nsubjects){'),'
      asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),' = (diag_matrix(rep_vector(1, nlatent*nlatent)) - 
        kron_prod(DRIFT',checkvarying('DRIFT','[individual]','[1]'),',DRIFT',checkvarying('DRIFT','[individual]','[1]'),')) * 
        to_vector(DIFFUSION',checkvarying('DIFFUSION','[individual]','[1]'),');
      for(drowi in 1:nlatent) {
      for(dcoli in 1:nlatent){
      asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),'[drowi,dcoli] = 
        asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[individual]','[1]'),'[drowi+(dcoli-1)*nlatent];
      }}
      '),'
    ',checkvarying(c('DIFFUSION','DRIFT'),'}'),'
      }    
}


model{
matrix[nlatent,nlatent] discreteDIFFUSION; //discrete time parameter matrices
vector[nlatent] discreteCINT;
matrix[nlatent,nlatent] discreteDRIFT;

',if(kalman==TRUE) paste0('
  vector[nlatent] etaprior[ndatapoints]; //prior for latent states
  matrix[nlatent, nlatent] etapriorcov[ndatapoints]; //prior for covariance of latent states
  vector[nlatent] etapost[ndatapoints + 1]; //posterior for latent states
  matrix[nlatent, nlatent] etapostcov[ndatapoints + 1]; //posterior for covariance of latent states
  vector[sum(nobs_y)] errtrans; // collection of prediction errors transformed to standard normal
  int obscount; // counter summing over number of non missing observations in each row
  '),'

hypermeans~normal(0,1);

',if(n.TIpred > 0) paste0('tipredeffectparams ~ normal(0,1); \n '),' 

',if(any(ctspec$indvarying)) paste0('
  hypersd ~ normal(0,1);
  ',if(stdnorm) 'indparamstrans ~ normal(0,1);
  target +=(sum(log(diagonal(invparamchol)))*nsubjects); //adjust loglik for density warping transform of prediction errors',
  
if(!stdnorm) paste0('
  for(subjecti in 1:nsubjects){ // transform subject parameters to standard normal dist
    indparams[subjecti]~multi_normal_cholesky(rep_vector(0,nindvarying) ',
      if(n.TIpred>0) '+ tipredeffect * tipreds[subjecti]\' ',
      if(!noncentered) '+ hypermeans[indvaryingindex]',
      ',paramchol);
  }
      '),'
  '),' 

',if(sum(ctspec$indvarying)>1 & densehyper==TRUE) 'hypercholcorr ~ lkj_corr_cholesky(4);','






',if(kalman==FALSE) paste0('
  {
  vector[(ndatapoints-nsubjects)*nlatent] etatrans; //collection of latent states transformed to standard normal
  vector[sum(nobs_y)] Ytrans; //collection of observations transformed to standard normal
  matrix[nmanifest,nmanifest] invMANIFESTVARchol; //inverse of cholesky of manifest variance
  matrix[nlatent,nlatent]invdiscreteDIFFUSIONchol; //inverse of cholesky of discrete time latent variance
  int subjecti;
  int etarow;
  
  for(rowi in 1:ndatapoints){
  int whichobs[nobs_y[rowi]];
  whichobs = whichobs_y[rowi][1:nobs_y[rowi]];
  subjecti = subject[rowi];
  etarow = rowi-subjecti;
  
  if(T0check[rowi]==1) { // if first row for this subjecti
  invMANIFESTVARchol = inverse(cholesky_decompose(MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'));
  ',if(continuoustime==FALSE) paste0('
    discreteDRIFT= DRIFT',checkvarying('DRIFT','[subjecti]','[1]'),';
    discreteCINT= CINT',checkvarying('CINT','[subjecti]','[1]'),';
    invdiscreteDIFFUSIONchol = cholesky_decompose(inverse_spd(DIFFUSION',checkvarying('DIFFUSION','[subjecti]','[1]'),'));
    '),'
  }
  
  ',if(continuoustime==TRUE) paste0('if(T0check[rowi]==0 && intervalChange[rowi]==1){ // if the time interval changes and its not the first row
  discreteDRIFT= expmp(DRIFT',checkvarying('DRIFT','[subjecti]','[1]'),' * dT[rowi], padeC, padeCbig);
  discreteCINT= invDRIFT',checkvarying('DRIFT','[subjecti]','[1]'),' * (discreteDRIFT - IIlatent) * CINT',checkvarying('CINT','[subjecti]','[1]'),';
  discreteDIFFUSION = asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subjecti]','[1]'),' - 
      quad_form(asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subjecti]','[1]'),' , discreteDRIFT\');
  ',if(stdnorm) 'invdiscreteDIFFUSIONchol = inverse(cholesky_decompose(discreteDIFFUSION));','
  }'),'
  
  ',if(stdnorm) paste0('
  if(T0check[rowi] ==0){ //transform latent states to standard normal and increment loglik to acccount for density warp
  
  if(T0check[rowi-1] ==1)  etatrans[((rowi-1-subjecti)*nlatent+1) : ((rowi-subjecti)*nlatent)] = 
  invdiscreteDIFFUSIONchol * (eta[etarow] - discreteDRIFT * T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),' - discreteCINT',
  if(n.TDpred > 0) paste0('- TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi]'),
  '); \n','
  
  if(T0check[rowi-1] ==0)  etatrans[((rowi-1-subjecti)*nlatent+1) : ((rowi-subjecti)*nlatent)] = 
  invdiscreteDIFFUSIONchol * (eta[etarow] - discreteDRIFT * eta[etarow-1] + discreteCINT',
  if(n.TDpred > 0) paste0('- TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi]'),
  '); \n','
  
  target +=(sum(log(diagonal(invdiscreteDIFFUSIONchol))));
  }
  
  if(T0check[rowi] ==0 && nobs_y[rowi]>0) Ytrans[((rowi-1)*nmanifest+1):((rowi-1)*nmanifest+nobs_y[rowi])] = 
    invMANIFESTVARchol[whichobs_y[rowi],whichobs_y[rowi]] * (Y[rowi][whichobs] - LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs] * 
    eta[etarow] - MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]);
  
  if(T0check[rowi] ==1 && nobs_y[rowi]>0) Ytrans[((rowi-1)*nmanifest+1):((rowi-1)*nmanifest+nobs_y[rowi])] = 
    invMANIFESTVARchol[whichobs,whichobs] * (Y[rowi][whichobs] - LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs] * 
    T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),' - MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]);
  
  target +=(sum(log(diagonal(invMANIFESTVARchol[whichobs,whichobs]))));
  }
  etatrans~normal(0,1);
  Ytrans~normal(0,1);
  '),'
  
  
  
  ',if(!stdnorm) paste0('
  if(T0check[rowi] ==0){ // latent states
    if(T0check[rowi-1] ==1)  eta[etarow]~ multi_normal(discreteDRIFT * T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),' - discreteCINT', 
      if(n.TDpred > 0) paste0('+ TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi]'),
      ', discreteDIFFUSION);

    if(T0check[rowi-1] ==0)  eta[etarow]~ multi_normal(discreteDRIFT * eta[etarow-1] - discreteCINT', 
      if(n.TDpred > 0) paste0('+ TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi]'),
      ', discreteDIFFUSION);
  }

  if(T0check[rowi] ==0 && nobs_y[rowi]>0) Y[rowi][whichobs] ~ multi_normal(LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs,] * 
    eta[etarow] + MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs] , 
    MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs]);

  if(T0check[rowi] ==1 && nobs_y[rowi]>0) Y[rowi][whichobs] ~ multi_normal(LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs,] * 
    T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),'+ 
    MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs], 
    MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs]);


}
'),'
  
  
  }
  
  '),'


',if(kalman==TRUE) paste0('      
  
  obscount=1;
  {
  int subjecti;
  int nobsi;
  
  for(rowi in 1:ndatapoints){
  int whichobs[nobs_y[rowi]];
  whichobs = whichobs_y[rowi][1:nobs_y[rowi]];
  subjecti=subject[rowi];
  nobsi = nobs_y[rowi];
  
  if(rowi!=1) obscount=obscount+nobs_y[rowi-1]; // number of non missing observations until now
  
  if(T0check[rowi] == 1) { // calculate initial matrices if this is first row for subjecti
  
  ',if(continuoustime==FALSE) paste0('
    discreteDRIFT= DRIFT',checkvarying('DRIFT','[subjecti]','[1]'),'; // discrete time models dont need to be udpdated each row
    discreteCINT= CINT',checkvarying('CINT','[subjecti]','[1]'),';
    discreteDIFFUSION = DIFFUSION',checkvarying('DIFFUSION','[subjecti]','[1]'),';'),'
  
  etaprior[rowi] = T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),'; //prior for latent state of this row
  ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi] + etaprior[rowi];'),'
  etapriorcov[rowi] =  T0VAR',checkvarying('T0VAR','[subjecti]','[1]'),';
  }
  
  if(T0check[rowi]==0){
  ',if(continuoustime==TRUE) paste0('
    if(intervalChange[rowi]==1){ // if the time interval changes we need to calculate new discrete time matrices
    discreteDRIFT= expmp(DRIFT',checkvarying('DRIFT','[subjecti]','[1]'),' * dT[rowi], padeC, padeCbig);
    discreteCINT= invDRIFT',checkvarying('DRIFT','[subjecti]','[1]'),' * (discreteDRIFT - IIlatent) * CINT',checkvarying('CINT','[subjecti]','[1]'),';
    discreteDIFFUSION = asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subjecti]','[1]'),' - 
      quad_form_sym(asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subjecti]','[1]'),', discreteDRIFT\');
    }'),'
  etaprior[rowi] = discreteCINT  + discreteDRIFT * etapost[rowi]; //prior for latent state of this row
  ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi-1] + etaprior[rowi];'),'
  etapriorcov[rowi] =  quad_form(etapostcov[rowi], discreteDRIFT\')  + discreteDIFFUSION;
    }
   
if(nobsi==0){     // if no observations...
  etapost[rowi + 1] = etaprior[rowi];
  etapostcov[rowi + 1] = etapriorcov[rowi];
}
  
  if (nobsi > 0) {  // if some observations create right size matrices for missingness and calculate...
  vector[nobsi] Y_filt;
  matrix[nobsi, nlatent] LAMBDA_filt;
  vector[nobsi] MANIFESTMEANS_filt;
  matrix[nobsi, nobsi] MANIFESTVAR_filt;
  vector[nobsi] Ypred_filt;      
  matrix[nobsi, nobsi] Ypredcov_filt;
  vector[nobsi] err;
  matrix[nlatent, nobsi] K_filt; // kalman gain
  matrix[nobsi, nobsi] invYpredcov_filt;
  matrix[nobsi, nobsi] invYpredcov_filt_chol;
  
  Y_filt = Y[rowi][whichobs]; // filter the data
  MANIFESTMEANS_filt = MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]; // and manifest means
  LAMBDA_filt = LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs]; // and loading matrix
  MANIFESTVAR_filt = MANIFESTVAR',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs,whichobs]; // and manifest variance
  
  Ypred_filt = MANIFESTMEANS_filt + LAMBDA_filt * etaprior[rowi]; // predictions of y given prior
  Ypredcov_filt = quad_form(etapriorcov[rowi], LAMBDA_filt\') + MANIFESTVAR_filt;
  
  err = Y_filt - Ypred_filt; // prediction error
  
  invYpredcov_filt = inverse_spd(Ypredcov_filt) ;
  invYpredcov_filt_chol=cholesky_decompose(invYpredcov_filt); 
  
  K_filt = etapriorcov[rowi] * LAMBDA_filt\' * invYpredcov_filt; 
  
  etapost[(rowi + 1)] = etaprior[rowi] + K_filt * err;
  
  etapostcov[(rowi + 1)] = (IIlatent - K_filt * LAMBDA_filt) * etapriorcov[rowi];
  
  errtrans[obscount:(obscount+nobsi-1)]=invYpredcov_filt_chol*err; //transform pred errors to standard normal dist and collect
  target +=(sum(log(diagonal(invYpredcov_filt_chol)))); //account for transformation of scale in loglik
  }
}

  errtrans~normal(0,1); 
  }
  '),'









', if(optimize==TRUE && n.TIpred > 0) paste0('print("tipredeffect ",tipredeffect);'),'
', if(optimize==TRUE | vb==TRUE) paste0('
  //print("hypersd",hypersd);
  //print("hypercholcorr",hypercholcorr);
  print("DRIFT ", DRIFT[1]);
  //print("DIFFUSION ", DIFFUSION[1]);
  //print("T0VAR ", T0VAR[1]);
  //print("MANIFESTVAR ", MANIFESTVAR[1]);
  //print("T0MEANS[1] ", T0MEANS[1]);
  //print("CINT ", CINT[1]);
  print("MANIFESTMEANS ", MANIFESTMEANS[1]);
  print("lp =",get_lp());
  '),'\n

  }
generated quantities{

',if(nindvarying > 1) 'matrix[nindvarying,nindvarying] output_indparams_cor; \n','

',paste0('real output_hmean_',ctspec$param[is.na(ctspec$value)],'; \n',collapse=''),'

',if(nindvarying > 1) paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(ctspec$indvarying[rowi]) paste0('real output_hsd_',ctspec$param[rowi],'; \n')
})),collapse=''),'

',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
  paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
    if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('real output_tip_',
      TIpredNames[tip], '_on_', ctspec$param[rowi],'; \n'
    )
  })),collapse='')
  })),collapse=''),'

',if(nindvarying > 1) paste0('
  {
  vector[nindvarying] output_indmeans;
  matrix[nsubjects,nindvarying] output_indparams_centered;
  matrix[nsubjects,nindvarying] output_indparams;
  for(subjecti in 1:nsubjects){
  ',
  paste0(unlist(lapply(1:nindvarying,function(indvi){
    paste0('output_indparams[subjecti,',indvi,'] = ',
      gsub('param', paste0('indparams[subjecti,',indvi,']'),ctspec$transform[ctspec$indvarying][indvi]),'; \n')})),collapse=''),'
  }
  for (parami in 1:nindvarying){
  output_indmeans[parami] = mean(col(output_indparams, parami));
  for (subjecti in 1:nsubjects)  {
  output_indparams_centered[subjecti,parami] = output_indparams[subjecti,parami] - output_indmeans[parami];
  }
  }
  output_indparams_cor = output_indparams_centered\' * output_indparams_centered / (nsubjects-1);
  output_indparams_cor = .5*(output_indparams_cor + output_indparams_cor\'); 
  output_indparams_cor = inverse(diag_matrix(vecsqrt(diagonal(output_indparams_cor)))) * output_indparams_cor * inverse(diag_matrix(vecsqrt(diagonal(output_indparams_cor))));
  }'),'

',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(is.na(ctspec$value[rowi])) paste0('output_hmean_',ctspec$param[rowi],' = ',
    gsub('param',
      paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
      ctspec$transform[rowi]),'; \n')
  })),collapse=''),'


',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(ctspec$indvarying[rowi]) paste0('output_hsd_',ctspec$param[rowi],' = ',
    'hypersd[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),'] * 
    sdscale[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),']; \n',
    if(!is.na(ctspec$transform[rowi])) paste0(
      'output_hsd_',ctspec$param[rowi],' = fabs
      (', 
      gsub('param', paste0('(hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + output_hsd_',ctspec$param[rowi]),ctspec$transform[rowi]), ') - (',
      gsub('param', paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - output_hsd_',ctspec$param[rowi]),ctspec$transform[rowi]),'))/2; \n')
  )
})),collapse=''),'


',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
  paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
    if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('
      output_tip_',TIpredNames[tip], '_on_', ctspec$param[rowi],' = ',
      'tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']; \n',
      if(!is.na(ctspec$transform[rowi])) paste0('output_tip_', TIpredNames[tip], '_on_', ctspec$param[rowi],' = ((', 
        gsub('param', 
          paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
          ctspec$transform[rowi]), 
        ') - (',
        gsub('param', 
          paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
          ctspec$transform[rowi]),'))/2; \n')
    )
  })),collapse='')
  })),collapse=''),'
    
}')

  out<-stanmodelobj
  
  if(fit==TRUE){
    
    
    standata<-list(
      Y=cbind(datalong[,manifestNames]),
      subject=datalong[,'id'],
      nsubjects=nsubjects,
      nmanifest=n.manifest,
      T0check=T0check,
      indvaryingindex=which(ctspec$indvarying[is.na(ctspec$value)]),
      continuoustime=sum(continuoustime),
      nlatent=n.latent,
      ntipred=n.TIpred,
      ntdpred=n.TDpred,
      nparams=nparams,
      nindvarying=nindvarying,
      sdscale=ctspec$sdscale[ctspec$indvarying],
      IIparams = diag(nparams),
      ndatapoints=nrow(datalong),
      padeC=rbind(c(120, 60, 12, 1, 0, 0, 0, 0, 0, 0), c(30240, 
        15120, 3360, 420, 30, 1, 0, 0, 0, 0), c(17297280, 
          8648640, 1995840, 277200, 25200, 1512, 56, 1, 0, 
          0), c(17643225600, 8821612800, 2075673600, 302702400, 
            30270240, 2162160, 110880, 3960, 90, 1)),
      padeCbig= c(64764752532480000, 32382376266240000, 7771770303897600, 
        1187353796428800, 129060195264000, 10559470521600, 
        670442572800, 33522128640, 1323241920, 40840800, 
        960960, 16380, 182, 1),
      dT=dT,
      intervalChange=intervalChange,
      nobs_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[x!=99999])),dim=nrow(datalong)),
      whichobs_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
        out<-as.numeric(which(x!=99999))
        if(length(out)==0) out<-rep(0,n.manifest)
        if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
        out
      }) ),nrow=c(nrow(datalong),ncol=n.manifest)))
    
    if(n.TIpred > 0) standata$tipreds <- tipreds
    
    if(n.TDpred > 0) standata<-c(standata,list(tdpreds=array(tdpreds,dim=c(nrow(tdpreds),ncol(tdpreds)))))

  
    
    control<-list(adapt_delta=adapt_delta,
      adapt_term_buffer=min(c(iter/10,75)),
      adapt_init_buffer=2,
      adapt_window=2,
      # adapt_kappa=.95,
      # adapt_gamma=.01,
      # metric="dense_e",
      max_treedepth=12,stepsize=.001)
    
    stanseed<-floor(runif(1,1,99999))
    if(plot==TRUE) {
      stanplot(chains=chains,seed=stanseed)
    }
    if(!exists('sample_file')){
      if(plot==TRUE) sample_file<-paste0(stanseed,'samples.csv')
      if(plot==FALSE) sample_file<-NULL
    }
    
    out <- stan(model_code = c(stanmodelobj), 
      enable_random_init=TRUE,init_r=.5,
      refresh=20,
      iter=iter,
      data = standata, chains = ifelse(optimize==FALSE & vb==FALSE,chains,0), control=control,
      sample_file=sample_file,
      cores=max(c(chains,detectCores())),...) 
    
    
    
    if(optimize==FALSE & vb==FALSE){ #summarise
      if(plot==TRUE) {
        for(chaini in 1:chains) system(paste0("rm ",stanseed,"samples.csv",chaini))
        system(paste0('rm stanplottemp.R'))
      }
    }
    
    if(optimize==TRUE && fit==TRUE) {
      out <- optimizing(object = out@stanmodel, 
        # init=0,
        # algorithm='BFGS',
        as_vector=F,
        history_size=10,
        # init_alpha=.001,
        tol_obj=1e-14, tol_grad=1e-14,tol_param=1e-14,tol_rel_grad=0, tol_rel_obj=0,
        data = standata, iter=120000)
      
      
    }
    
    if(vb==TRUE && fit==TRUE) {
      out <- vb(object = out@stanmodel, 
        iter=iter,
        data = standata,...)
      
    }
    
  } # end if fit==TRUE
  
  
  
  return(out)
  }
