#' ctStanFit
#'
#' Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
#' Stan. 
#' 
#' @param datalong long format data containing columns for subject id (numeric values, 1 to max subjects), manifest variables, 
#' any time dependent (i.e. varying within subject) predictors, 
#' and any time independent (not varying within subject) predictors.
#' @param ctstanmodel model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt', for continuous or discrete time
#' models respectively.
#' @param stanmodeltext already specified Stan model character string, generally leave NA unless modifying Stan model directly.
#' (Possible after modification of output from fit=FALSE)
#' @param kalman logical indicating whether or not to integrate over latent states using a Kalman filter. 
#' Generally recommended to set TRUE unless using non-gaussian measurement model. If not using Kalman filter, experience
#' suggests that some models / datasets require a relatively high amount of very fast iterations before the sampler is
#' in the high density region. This can make it difficult to determine the number of iterations needed a priori - in such cases 
#' setting initwithoptim=TRUE may be helpful.
#' @param binomial logical indicating the use of binomial rather than Gaussian data, as with IRT analyses.
#' @param estpop Logical indicating whether to explictly estimate distributions for any individually varying
#' parameters, or to fix the distributions to maximum likelihood estimates conditional on subject parameters.
#' @param noncentered Logical. If TRUE, uses a noncentered parameterization. For longer (perhaps 100+ time points)
#' time series, may need to be set to FALSE.
#' @param fit If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.
#' @param ukfpop if TRUE, uses an unscented approximation for population distributions rather than full sampling.
#' @param plot if TRUE, a Shiny program is launched upon fitting to interactively plot samples. 
#' May struggle with many (e.g., > 5000) parameters, and may leave sample files in working directory if sampling is terminated.
#' @param diffusionindices vector of integers denoting which latent variables are involved in covariance calculations.
#' latents involved only in deterministic trends or input effects can be removed from matrices, speeding up calculations. 
#' If unsure, leave default of 'all' ! Ignored if kalman=FALSE.
#' @param asymdiffusion if TRUE, increases fitting speed at cost of model flexibility - T0VAR in the model specification is ignored, the DIFFUSION matrix specification is used as the 
#' asymptotic DIFFUSION matrix (Q*_inf in the vignette / paper) (making it difficult if not impossible to properly specify
#' higher order processes). The speed increases come about because the internal Kalman filter routine has many steps removed, and the
#' asymptotic diffusion parameters are less dependent on the DRIFT matrix.
#' @param optimize if TRUE, use Stan's optimizer for maximum a posteriori estimates. 
#' @param nopriors logical. If TRUE, any priors are disabled, can be desirable for optimization.
#' @param vb if TRUE, use Stan's variational approximation. Rudimentary testing suggests it is not accurate 
#' for many ctsem models at present.
#' @param iter number of iterations, half of which will be devoted to warmup by default when sampling.
#' When optimizing, this is the maximum number of iterations to allow -- convergence hopefully occurs before this!
#' @param inits vector of parameter start values, as returned by the rstan function \code{\link{unconstrain_pars}} for instance. 
#' @param initwithoptim Logical. If TRUE, the model, with population standard deviations fixed to 1 
#' (so approx 65% of the population mean prior), is first fit with penalised maximum likelihood to determine starting values
#' for the chains. This can help speed convergence and avoid problematic regions for certain problems.
#' @param chains number of chains to sample.
#' @param cores number of cpu cores to use. Either 'maxneeded' to use as many as available,
#' up to the number of chains, or an integer.
#' @param control List of arguments sent to \code{\link[rstan]{stan}} control argument, 
#' regarding warmup / sampling behaviour.
#' @param verbose Logical. If TRUE, prints log probability at each iteration.
#' @param stationary Logical. If TRUE, T0VAR and T0MEANS input matrices are ignored, 
#' the parameters are instead fixed to long run expectations. More control over this can be achieved
#' by instead setting parameter names of T0MEANS and T0VAR matrices in the input model to 'stationary', for
#' elements that should be fixed to stationarity.
#' @param maxtimestep positive numeric, only used for models with non-linear dynamics, specifying the largest time
#' span covered by the Runge-Kutta 4 integration. The large default ensures that for each observation time interval, 
#' only RK4 integration is used. When \code{maxtimestep} is smaller than the observation time interval, RK4 integration is used within an Euler loop. 
#' Smaller values may offer greater accuracy, but are slower and often unnecessary. In case of initial value problems, reducing
#' this is one thing to try.
#' @param lineardynamics Logical. Set to TRUE to use linear dynamics -- faster but only accurate when dynamic
#' parameters do not change over time.
#' @param ... additional arguments to pass to \code{\link[rstan]{stan}} function.
#' @examples
#' \dontrun{
#' #test data with 2 manifest indicators measuring 1 latent process each, 
#' # 1 time dependent predictor, 3 time independent predictors
#' head(ctstantestdat) 
#' 
#' #generate a ctStanModel
#' model<-ctModel(type='stanct',
#' n.latent=2, latentNames=c('eta1','eta2'),
#' n.manifest=2, manifestNames=c('Y1','Y2'),
#' n.TDpred=1, TDpredNames='TD1', 
#' n.TIpred=3, TIpredNames=c('TI1','TI2','TI3'),
#' LAMBDA=diag(2))
#' 
#' #set all parameters except manifest means to be fixed across subjects
#' model$pars$indvarying[-c(19,20)] <- FALSE
#' 
#' #fit model to data (takes a few minutes - but insufficient 
#' # iterations and max_treedepth for inference!)
#' fit<-ctStanFit(ctstantestdat, model, iter=200, chains=2, 
#' control=list(max_treedepth=6))
#' 
#' #output functions
#' summary(fit) 
#' 
#' plot(fit)
#' 
#' }
#' @importFrom Rcpp evalCpp
#' @export
ctStanFit_ukfupdate<-function(datalong, ctstanmodel, stanmodeltext=NA, iter=1000, kalman=TRUE, binomial=FALSE,
  estpop=TRUE, noncentered=TRUE, fit=TRUE, ukfpop=FALSE, stationary=FALSE,plot=FALSE,  diffusionindices='all',
  asymdiffusion=FALSE,optimize=FALSE, nopriors=FALSE, vb=FALSE, chains=1,cores='maxneeded', inits=NULL,initwithoptim=FALSE,
  maxtimestep = 9999, lineardynamics=FALSE,
  control=list(adapt_delta=.8, adapt_init_buffer=2, adapt_window=2,
    max_treedepth=8,stepsize=.001),verbose=FALSE,...){
  
  if(class(ctstanmodel) != 'ctStanModel') stop('not a ctStanModel object')
  
  args=match.call()
  
  ukf=FALSE
  if(ukfpop & any(ctstanmodel$pars$indvarying)) ukf=TRUE
  if(!is.null(ctstanmodel$calcs)) ukf=TRUE
  nonexplosive=FALSE
  fixedkalman=FALSE
  
  idName<-ctstanmodel$subjectIDname
  timeName<-ctstanmodel$timeName
  continuoustime<-ctstanmodel$continuoustime
  
  if(length(unique(datalong[,idName]))==1 & any(ctstanmodel$pars$indvarying==FALSE)) {
    ctstanmodel$pars$indvarying <- FALSE
    message('Individual variation not possible as only 1 subject! indvarying set to FALSE on all parameters')
  }
  
  checkvarying<-function(matrixnames,yesoutput,nooutput=''){#checks if a matrix is set to individually vary in ctspec
    check<-0
    out<-nooutput
    if('T0VAR' %in% matrixnames & nt0varstationary > 0) matrixnames <- c(matrixnames,'DRIFT','DIFFUSION')
    if('T0MEANS' %in% matrixnames & nrow(t0meansstationary) > 0) matrixnames <- c(matrixnames,'DRIFT','CINT')
    for( matname in matrixnames){
      if(any(c(ctspec$indvarying,ctspecduplicates$indvarying)[c(ctspec$matrix,ctspecduplicates$matrix) %in% matrixnames])) check<-c(check,1)
    }
    if(sum(check)==length(matrixnames))  out<-yesoutput
    return(out)
  }
  
  dynamicmatrices <- c('DRIFT','DIFFUSION','CINT','TDPREDEFFECT')
  measurementmatrices <- c('LAMBDA','MANIFESTMEANS','MANIFESTVAR')
  t0matrices <- c('T0MEANS','T0VAR')
  
  
  #read in ctmodel values
  ctspec<-ctstanmodel$pars
  
  if(binomial) {
    ctspec<-ctspec[ctspec$matrix != 'MANIFESTVAR',]
    message(paste0('MANIFESTVAR matrix is ignored when binomial=TRUE'))
  }
  
  manifesttype=ctstanmodel$manifesttype
  if(any(manifesttype!=0)){ #if any non continuous variables, (with free parameters)...
    ukf = TRUE #need nonlinear filter
    if(any(is.na(as.numeric(c(ctspec$value[ctspec$matrix=='MANIFESTVAR'][ctspec$row[ctspec$matrix=='MANIFESTVAR'] %in% which(manifesttype!=0)],
      ctspec$value[ctspec$matrix=='MANIFESTVAR'][ctspec$col[ctspec$matrix=='MANIFESTVAR'] %in% which(manifesttype!=0)]))))){
    message('Fixing any free MANIFESTVAR parameters for binary indicators to deterministic calculation')
    ctspec$value[ctspec$matrix=='MANIFESTVAR'][ctspec$row[ctspec$matrix=='MANIFESTVAR'] %in% which(manifesttype!=0)] <- 0
    ctspec$value[ctspec$matrix=='MANIFESTVAR'][ctspec$col[ctspec$matrix=='MANIFESTVAR'] %in% which(manifesttype!=0)] <- 0
  }}
  
  #clean ctspec structure
  found=FALSE
  ctspec$indvarying=as.logical(ctspec$indvarying)
  ctspec$value=as.numeric(ctspec$value)
  ctspec$transform=as.character(ctspec$transform)
  ctspec$param=as.character(ctspec$param)
  comparison=c(NA,NA,'FALSE')
  replacement=c(NA,NA,FALSE)
  # names(comparison)=c('param','transform','indvarying')
  for(rowi in 1:nrow(ctspec)){
    if( !is.na(ctspec$value[rowi])) {
      if(!identical(as.character(unlist(ctspec[rowi,c('param','transform','indvarying')])),comparison)) {
        found<-TRUE
        ctspec[rowi,c('param','transform','indvarying')]=replacement
      }
    }
  }
  if(found) message('Minor inconsistencies in model found - removing param name, transform and indvarying from any parameters with a value specified')
  
  #remove T0VAR and T0MEANS if stationary argument
  if(stationary) {
    ctspec=ctspec[ctspec$matrix %in% c('T0VAR','T0MEANS')==FALSE,,drop=FALSE]
    message('removing T0VAR and T0MEANS from parameter matrices because stationary=TRUE')
  }
  

  
  
  ctstanmodel$pars <- ctspec #updating because we save the model later
  

  
  #collect individual stationary elements and update ctspec
  t0varstationary <- as.matrix(rbind(ctspec[which(ctspec$param %in% 'stationary' & ctspec$matrix %in% 'T0VAR'),c('row','col')]))
  if(nrow(t0varstationary) > 0){ #ensure upper tri is consistent with lower
    for(i in 1:nrow(t0varstationary)){
      if(t0varstationary[i,1] != t0varstationary[i,2]) t0varstationary <- rbind(t0varstationary,t0varstationary[i,c(2,1)])
    }}
  

  t0meansstationary <- as.matrix(rbind(ctspec[which(ctspec$param[ctspec$matrix %in% 'T0MEANS'] %in% 'stationary'),c('row','col')]))
  ctspec$value[ctspec$param %in% 'stationary'] <- 0
  ctspec$indvarying[ctspec$param %in% 'stationary'] <- FALSE
  ctspec$transform[ctspec$param %in% 'stationary'] <- NA
  ctspec$param[ctspec$param %in% 'stationary'] <- NA
  
  nt0varstationary <- nrow(t0varstationary)
  # if(nt0varstationary ==0) t0varstationary <- matrix(-99,ncol=2)
  nt0meansstationary <- nrow(t0meansstationary)
  # if(nt0meansstationary ==0) t0meansstationary <- matrix(-99,ncol=2)

  
  #split ctspec into unique and non-unique components
  ctspecduplicates <- ctspec[duplicated(ctspec$param)&!is.na(ctspec$param),]
  popmeanduplicates<-c()
  if(any(duplicated(ctspec$param)&!is.na(ctspec$param))){
    for(i in 1:nrow(ctspecduplicates)){
      popmeanduplicates[i] = paste0('rawpopmeans[',match(ctspecduplicates$param[i], unique(ctspec$param[!is.na(ctspec$param)])),']')
    }
  }

  ctspec <- ctspec[!duplicated(ctspec$param) | is.na(ctspec$param),]
  ctspecduplicates=cbind(ctspecduplicates,popmeanduplicates)
  
  
  driftdiagonly <- ifelse(all(!is.na(ctspec$value[ctspec$matrix == 'DRIFT' & ctspec$row != ctspec$col]) &
     all(ctspec$value[ctspec$matrix == 'DRIFT' & ctspec$row != ctspec$col] == 0) ), 1, 0)
  
  n.latent<-ctstanmodel$n.latent
  n.manifest<-ctstanmodel$n.manifest
  n.TDpred<-ctstanmodel$n.TDpred
  n.TIpred<-ctstanmodel$n.TIpred
  
  manifestNames<-ctstanmodel$manifestNames
  latentNames<-ctstanmodel$latentNames
  TDpredNames<-ctstanmodel$TDpredNames
  TIpredNames<-ctstanmodel$TIpredNames
  indvarying<-c(ctspec$indvarying,ctspecduplicates$indvarying)
  nindvarying<-sum(ctspec$indvarying)
  nparams<-sum(is.na(ctspec$value))
  
  
  #data checks
  if (!(idName %in% colnames(datalong))) stop(paste('id column', omxQuotes(idName), "not found in data"))
  
  #fit spec checks
  if(binomial & any(kalman)) stop('Binomial observations only possible with kalman=FALSE')
  
  original <- unique(datalong[,idName])
  datalong <- makeNumericIDs(datalong,idName,timeName)
  new <- unique(datalong[,idName])
  idmap <- cbind(original, new)
  
  T0check<-rep(1,nrow(datalong))
  for(i in 2:nrow(datalong)){
    T0check[i]<- ifelse(datalong[i,idName] != datalong[i-1,idName], 1, 0)
  }
  
  if (!(timeName %in% colnames(datalong))) stop(paste('time column', omxQuotes(timeName), "not found in data"))
  if(any(is.na(datalong[,timeName]))) stop('Missing "time" column!')
  
  #check id and calculate intervals, discrete matrix indices
  driftindex<-rep(0,nrow(datalong))
  diffusionindex<-driftindex
  cintindex<-driftindex
  oldsubi<-0
  dT<-rep(-1,length(datalong[,timeName]))
  
  for(rowi in 1:length(datalong[,timeName])) {
    subi<-datalong[rowi,idName]
    if(rowi==1 && subi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
    if(oldsubi!=subi && subi-oldsubi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
    if(subi - oldsubi == 1) {
      dT[rowi]<-0
      subistartrow<-rowi
    }
    if(subi - oldsubi == 0) {
      if(continuoustime) dT[rowi]<-round(datalong[rowi,timeName] - datalong[rowi-1,timeName],8)
      if(!continuoustime) dT[rowi]<-1
      if(dT[rowi] <=0) stop(paste0('A time interval of ', dT[rowi],' was found at row ',rowi))
      # if(subi!=oldsubi) intervalChange[rowi] <-  0
      # if(subi==oldsubi && dT[rowi] != dT[rowi-1]) intervalChange[rowi] <- 1
      # if(subi==oldsubi && dT[rowi] == dT[rowi-1]) intervalChange[rowi] <- 0
      
      if(!ukf){
      if(dT[rowi] %in% dT[1:(rowi-1)]) dTinwhole<-TRUE else dTinwhole<-FALSE
      if(dT[rowi] %in% dT[subistartrow:(rowi-1)]) dTinsub<-TRUE else dTinsub<-FALSE
      
      if(checkvarying('DRIFT',1,0)==0 & dTinwhole==FALSE) driftindex[rowi] <- max(driftindex)+1
      if(checkvarying('DRIFT',1,0)==1 & dTinsub==FALSE) driftindex[rowi] <- max(driftindex)+1
      if(checkvarying('DRIFT',1,0)==0 & dTinwhole==TRUE) driftindex[rowi] <- driftindex[match(dT[rowi],dT)]
      if(checkvarying('DRIFT',1,0)==1 & dTinsub==TRUE) driftindex[rowi] <- driftindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
      
      if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==0 & dTinwhole==FALSE) diffusionindex[rowi] <- max(diffusionindex)+1
      if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==1 & dTinsub==FALSE) diffusionindex[rowi] <- max(diffusionindex)+1
      if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==0 & dTinwhole==TRUE) diffusionindex[rowi] <- diffusionindex[match(dT[rowi],dT)]
      if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==1 & dTinsub==TRUE) diffusionindex[rowi] <- diffusionindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
      
      if(checkvarying(c('CINT','DRIFT'),1,0)==0 & dTinwhole==FALSE) cintindex[rowi] <- max(cintindex)+1
      if(checkvarying(c('CINT','DRIFT'),1,0)==1 & dTinsub==FALSE) cintindex[rowi] <- max(cintindex)+1
      if(checkvarying(c('CINT','DRIFT'),1,0)==0 & dTinwhole==TRUE) cintindex[rowi] <- cintindex[match(dT[rowi],dT)]
      if(checkvarying(c('CINT','DRIFT'),1,0)==1 & dTinsub==TRUE) cintindex[rowi] <- cintindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
    }}
    oldsubi<-subi
  }
  if(!ukf){
  message('Unique discreteDRIFT calculations per step required = ', length(unique(driftindex))-1)
  message('Unique discreteCINT calculations per step required = ', length(unique(cintindex))-1)
  message('Unique discreteDIFFUSION calculations per step required = ', length(unique(diffusionindex))-1)
  }
  # datalong[sort(c(which(dT > 5),which(dT > 5)+1,which(dT > 5)-1)),1:2]
  
  if(n.TDpred > 0) {
    tdpreds <- datalong[,TDpredNames,drop=FALSE]
    if(any(is.na(tdpreds))) message('Missingness in TDpreds! Replaced by zeroes...')
    tdpreds[is.na(tdpreds)] <-0 ## rough fix for missingness
  }
  if(n.TIpred > 0) {
    tipreds <- datalong[match(unique(datalong[,idName]),datalong[,idName]),TIpredNames,drop=FALSE]
    if(any(is.na(tipreds))) {
      message(paste0('Missingness in TIpreds - imputing ', sum(is.na(tipreds)),' values'))
      tipreds[is.na(tipreds)] = 99999
    }
  }
  
  datalong[is.na(datalong)]<-99999 #missing data
  
  nsubjects <- length(unique(datalong[, idName])) 
  
  indvaryingindex = array( #used to select rawpopmeans appropriately when generating subject params
    c(which(ctspec$indvarying[is.na(ctspec$value)]))) #unique rawpopmeans
      # match(ctspecduplicates$param[which(ctspecduplicates$indvarying[is.na(ctspecduplicates$value)])], ctspec$param[is.na(ctspec$value)] ) #duplicated rawpopmeans
      # )) 

  
  #
  # indvaryingcorindex= which(ctspec$param[ctspec$indvarying] %in% ctspec$param[is.na(ctspec$value) & 
  #     ctspec$indvarying & ctspec$row != ctspec$col & ctspec$matrix %in% c('T0VAR','DIFFUSION')])
  
  # DIFFUSION<-matrix(1,n.latent,n.latent)
  # for(rowi in ctspec$row[ctspec$matrix=='DIFFUSION' ]){
  #  DIFFUSION[
  
  #check diffusion indices input by user - which latents are involved in covariance
  if(diffusionindices=='all' || kalman==FALSE) diffusionindices = 1:n.latent
  diffusionindices = as.integer(diffusionindices)
  if(any(diffusionindices > n.latent)) stop('diffusionindices > than n.latent found!')
  if(length(diffusionindices) > n.latent) stop('diffusionindices vector cannot be longer than n.latent!')
  if(length(unique(diffusionindices)) < length(diffusionindices)) stop('diffusionindices vector cannot contain duplicates or!')
  ndiffusion=length(diffusionindices)
  message(paste(ndiffusion ,'/',n.latent,'latent variables required for covariance calculations'))
  
  
  #configure user specified calculations
  if(!is.null(ctstanmodel$calcs) | ukfpop)   ukf <- TRUE
  
  dynamiccalcs <- ctstanmodel$calcs[
    unlist(lapply(
      lapply(ctstanmodel$calcs, function(x) unlist(lapply(dynamicmatrices, function(y) grepl(y,x)))),
      function(z) any(z)))
    ]
  
  measurementcalcs <- ctstanmodel$calcs[
    unlist(lapply(
      lapply(ctstanmodel$calcs, function(x) unlist(lapply(measurementmatrices, function(y) grepl(y,x)))),
      function(z) any(z)))
    ]
  
    t0calcs <- ctstanmodel$calcs[
    unlist(lapply(
      lapply(ctstanmodel$calcs, function(x) unlist(lapply(t0matrices, function(y) grepl(y,x)))),
      function(z) any(z)))
    ]
  
  if(ukfpop & any(ctspec$indvarying)){ #need to account for duplicates here too
    ivtemp <- ctspec[ctspec$indvarying,]
    for(i in 1:nrow(ivtemp)){
      if(ivtemp$matrix[i] %in% dynamicmatrices){
       dynamiccalcs <- c(dynamiccalcs, paste0(ivtemp$matrix[i],'[',ivtemp$row[i],',',ivtemp$col[i],'] = ',
        gsub('param',paste0('state[nlatent + ',i,']'),ivtemp$transform[i])))
      }
      if(ivtemp$matrix[i] %in% measurementmatrices){
       measurementcalcs <- c(measurementcalcs, paste0(ivtemp$matrix[i],'[',ivtemp$row[i],',',ivtemp$col[i],'] = ',
        gsub('param',paste0('state[nlatent + ',i,']'),ivtemp$transform[i])))
      }
      if(ivtemp$matrix[i] %in% t0matrices){
       t0calcs <- c(t0calcs, paste0(ivtemp$matrix[i],'[',ivtemp$row[i],',',ivtemp$col[i],'] = ',
        gsub('param',paste0('state[nlatent + ',i,']'),ivtemp$transform[i])))
      }
    }
  }
  
for(mati in c('DRIFT','DIFFUSION','CINT','TDPREDEFFECT','LAMBDA','MANIFESTMEANS','MANIFESTVAR','T0MEANS','T0VAR')){
  dynamiccalcs <- gsub(mati,paste0('s',mati),dynamiccalcs)
  measurementcalcs <- gsub(mati,paste0('s',mati),measurementcalcs)
  t0calcs <- gsub(mati,paste0('s',mati),t0calcs)
}

#integration steps
integrationsteps <- sapply(dT,function(x)  ceiling(x / maxtimestep));

  
  verbosefilter<-function(){
    all <- c('etaprior[rowi]','etapriorcov[rowi]','Ypredcov_filt','Ypredcov_filt_sqrt',
      'K_filt','err','etaupd[rowi]','etaupdcov[rowi]')
    if(kalman) all <- c(all,'errscales[obscount:(obscount+nobsi-1)]','errtrans[obscount:(obscount+nobsi-1)]')
      
      t1plus<-c('discreteDRIFT[driftindex[rowi]]','discreteCINT[cintindex[rowi]]','discreteDIFFUSION[diffusionindex[rowi]]')
      out<-paste0('print("',all,' = ",', all,');')
      out<-c(out,paste0('if(T0check[rowi]==0) print("',t1plus,' = ",', t1plus,');'))
      return(paste0(out,collapse='\n '))
  }
  
  filteringfunc<-function(ppchecking){
    out<-paste0('
      {
      int subjecti;
      int counter;
      matrix[nlatent,nlatent] discreteDRIFT[',max(driftindex),']; 
      vector[nlatent] discreteCINT[',max(cintindex),'];
      ',if(!fixedkalman) paste0('matrix[ndiffusion,ndiffusion] discreteDIFFUSION[',max(diffusionindex),'];',
        if(!kalman) paste0('matrix[ndiffusion,ndiffusion] discreteDIFFUSIONsqrt[',max(diffusionindex),'];')),'
      vector[nlatent] etaprior[ndatapoints]; //prior for latent states
      ',if(kalman) paste0('matrix[ndiffusion, ndiffusion] etapriorcov[ndatapoints]; //prior for covariance of latent states
        vector[nlatent] etaupd[ndatapoints]; //posterior for latent states'),'
      ',if(kalman) 'matrix[ndiffusion, ndiffusion] etaupdcov[ndatapoints]; //posterior for covariance of latent states','
      ',if(!kalman) 'vector[nlatent] etaupd[ndatapoints]; \n','
      
      vector[sum(nobs_y)] errtrans; // collection of prediction errors transformed to standard normal
      vector[sum(nobs_y)] errscales; // collection of prediction error scaling factors
      int obscount; // counter summing over number of non missing observations in each row
      int nobsi; 
      
      // pre-calculate necessary discrete time matrices      
      counter=0;
      for(rowi in 1:ndatapoints) {
      if(T0check[rowi]==0 && (rowi==1 || driftindex[rowi] > counter)) { 
      discreteDRIFT[driftindex[rowi]] = ',
      if(!continuoustime) paste0('DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),';'),
      if(continuoustime & !driftdiagonly) paste0('matrix_exp(DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),' * dT[rowi]);'),
      if(continuoustime & driftdiagonly) paste0('matrix_diagexp(DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),' * dT[rowi]);'),'
      counter=counter+1;
      }
      }
      counter=0;

      for(rowi in 1:ndatapoints) {
      if(T0check[rowi]==0 && (rowi==1 || diffusionindex[rowi] > counter)){ 
      discreteDIFFUSION[diffusionindex[rowi]] = ',
      if(!continuoustime) paste0('DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),';'),
      if(continuoustime & !asymdiffusion) paste0('asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' - 
        quad_form_sym(asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' , discreteDRIFT[driftindex[rowi],diffusionindices,diffusionindices]\');'),
      if(continuoustime & asymdiffusion) paste0('DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),'[diffusionindices,diffusionindices] - 
        makesym(quad_form(DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),'[diffusionindices,diffusionindices] , discreteDRIFT[driftindex[rowi],diffusionindices,diffusionindices]\'),.00001);'),'
      counter=counter+1;
      ',if(!kalman) 'discreteDIFFUSIONsqrt[diffusionindex[rowi]] = cholesky_decompose(discreteDIFFUSION[diffusionindex[rowi]]);','
      }
      }
      counter=0;
      
      for(rowi in 1:ndatapoints) {
      if(T0check[rowi]==0 && (rowi==1 || cintindex[rowi] > counter)) { 
      discreteCINT[cintindex[rowi]] = ',
      if(!continuoustime) paste0('CINT',checkvarying('CINT','[subject[rowi]]','[1]'),';'),
      if(continuoustime) paste0('DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),' \\ (discreteDRIFT[driftindex[rowi]] - IIlatent) * CINT',
        checkvarying('CINT','[subject[rowi]]','[1]'),';'),'

      counter=counter+1;
      }
      }
      
      
      
      obscount=1; //running total of observed indicators
      for(rowi in 1:ndatapoints){
      int whichobs[nobs_y[rowi]];
      whichobs = whichobs_y[rowi,1:nobs_y[rowi]]; //which are not missing in this row
      subjecti=subject[rowi];
      nobsi = nobs_y[rowi]; //number of obs this row
      
      if(rowi!=1) obscount=obscount+nobs_y[rowi-1]; // number of non missing observations until now
      
      if(T0check[rowi] == 1) { // calculate initial matrices if this is first row for subjecti
      etaprior[rowi] = T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),'; //prior for initial latent state
      ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi] + etaprior[rowi];'),'
      ',if(kalman) paste0('etapriorcov[rowi] =  T0VAR',checkvarying('T0VAR','[subjecti]','[1]'),'[diffusionindices,diffusionindices];'),'
      etaupd[rowi] = etaprior[rowi];
      }
      
      if(T0check[rowi]==0){
      etaprior[rowi] = discreteCINT[cintindex[rowi]]  + discreteDRIFT[driftindex[rowi]] * etaupd[rowi-1]; //prior for latent state of this row
      ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi] + etaprior[rowi];'),'
      ',if(kalman) paste0('etapriorcov[rowi] =  makesym(quad_form(etaupdcov[rowi-1], discreteDRIFT[driftindex[rowi],diffusionindices,diffusionindices]\')  + discreteDIFFUSION[diffusionindex[rowi]],.00001);'),'
      ',if(!kalman) 'etaupd[rowi] = etaprior[rowi] +  discreteDIFFUSIONsqrt[diffusionindex[rowi]] * etaupdbase[(1+(rowi-1-subjecti)*nlatent):((rowi-subjecti)*nlatent)];','
      }
      
      ',if(kalman) 'etaupd[rowi] = etaprior[rowi];
        etaupdcov[rowi] = etapriorcov[rowi];','
      
      if (nobsi > 0) {  // if some observations create right size matrices for missingness and calculate...
      
      matrix[nobsi, nlatent] LAMBDA_filt;
      ',if(!binomial) 'vector[nobsi] err;','
      ',ifelse(binomial, 'int Y_filt[nobsi];','vector[nobsi] Y_filt;'),'
      
      ',if(kalman) paste0('
        matrix[nobsi, nobsi] Ypredcov_filt;
        //matrix[nobsi, nobsi] invYpredcov_filt_sqrt;
        matrix[ndiffusion, nobsi] K_filt; // kalman gain
        '),'
      
      ',if(!binomial) 'matrix[nobsi, nobsi] Ypredcov_filt_sqrt; \n','
      
      ',paste0('LAMBDA_filt = LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs]; // and loading matrix'),'
      

      ',if(kalman) paste0(
        'Ypredcov_filt = makesym(quad_form(etapriorcov[rowi], LAMBDA_filt[,diffusionindices]\'),.00001) + MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs];
    
Ypredcov_filt_sqrt=cholesky_decompose(Ypredcov_filt); 

       K_filt = mdivide_right_spd(etapriorcov[rowi] * LAMBDA_filt[,diffusionindices]\', Ypredcov_filt); 

       etaupdcov[rowi] = (IIlatent[diffusionindices,diffusionindices] - K_filt * LAMBDA_filt[,diffusionindices]) * etapriorcov[rowi];
        '),'
      
      ',if(!kalman & !binomial) paste0('Ypredcov_filt_sqrt = diag_matrix( sqrt(diagonal(MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs])));'),'
      
      ',if(!ppchecking) 'Y_filt = Y[rowi,whichobs];','
      
      ',if(kalman & ppchecking) paste0('Y_filt = multi_normal_rng( MANIFESTMEANS',
        checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs] + LAMBDA_filt * etaprior[rowi], Ypredcov_filt);'),'
      
      ',if(!kalman & !binomial & ppchecking) paste0('Y_filt = multi_normal_rng( MANIFESTMEANS',
        checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs] + LAMBDA_filt * etaprior[rowi], MANIFESTVAR',
        checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs]);'),'
      
      ',if(binomial & ppchecking) paste0('for(obsi in 1:nobsi) Y_filt[obsi] = bernoulli_rng(inv_logit(LAMBDA_filt * etaupd[rowi] + ', 
        'MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs])[obsi]);'),'



      ',if(kalman) paste0('err = Y_filt - ( MANIFESTMEANS',
        checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs] + LAMBDA_filt * etaprior[rowi] ); // prediction error'),
      if(!kalman & !binomial) paste0('err = Y_filt - ( MANIFESTMEANS',
        checkvarying('MANIFESTMEANS','[subjecti]','[1]'),
        '[whichobs] + LAMBDA_filt * etaupd[rowi] ); // measurement error'),'


      ',if(kalman) 'etaupd[rowi,diffusionindices] = etaprior[rowi,diffusionindices] + K_filt * err;','
      
      ',if(!binomial) '
      errtrans[obscount:(obscount+nobsi-1)]=mdivide_left_tri_low(Ypredcov_filt_sqrt, err); //transform pred errors to standard normal dist and collect
      errscales[obscount:(obscount+nobsi-1)]=log(diagonal(Ypredcov_filt_sqrt)); //account for transformation of scale in loglik ','
      
      ',if(binomial) paste0('ll =  ll + bernoulli_logit_lpmf(Y_filt | LAMBDA_filt * etaupd[rowi] + ', 
        'MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]);'),'

    ',if(verbose & 1==2) verbosefilter() ,'
      }
      }

      ',if(!binomial) 'll = ll+normal_lpdf(errtrans|0,1); 
      ll= ll - sum(errscales);','
      }
      ')
    return(out)
  }
  
  
  
   ukfilterfunc<-function(ppchecking){
    out<-paste0('
      {
      int subjecti;
      int counter;
      vector[nlatentpop+nlatent] etaprior[ndatapoints]; //prior for latent states
      vector[nlatentpop] etaupd[ndatapoints]; //updated latent states
      matrix[nlatentpop+nlatent, nlatentpop+nlatent] etapriorcov[ndatapoints]; //prior for covariance of latent states
      matrix[nlatentpop, nlatentpop] etaupdcov[ndatapoints]; //updated covariance of latent states
      
      vector[sum(nobs_y)] errtrans; // collection of prediction errors transformed to standard normal
      vector[sum(nobs_y)] errscales; // collection of prediction error scaling factors
      int obscount; // counter summing over number of non missing observations in each row
      int nobsi; 

      matrix[2*(nlatentpop+nlatent) +2, (nlatentpop+nlatent)] ukfstates; //sampled states relevant for dynamics
      matrix[nlatentpop+nlatent,nlatentpop+nlatent] sigpoints;
      vector[nlatentpop+nlatent] state; // current state
      real k;
      real a;
      real l;
      real sqrtukfadjust;
    
      ',if(!lineardynamics) paste0(
      'vector[nlatent] rkstates[5]; //runge kutta integration steps
      real dTsmall;
      '),'
  
      ',if(lineardynamics) paste0(
     'matrix[nlatent,nlatent] discreteDRIFT; 
      vector[nlatent] discreteCINT;
      matrix[nlatent, nlatent] discreteDIFFUSION;'),'

    // create simple, modifiable forms of the system matrices for easier use in the filter
      matrix[nlatent,1] sT0MEANS;
      matrix[nlatent,nlatent] sT0VAR;
      matrix[nlatent,nlatent] sDIFFUSION; 
      matrix[nlatent,nlatent] sDRIFT; 
      matrix[nlatent,1] sCINT;
      vector[nmanifest] sMANIFESTVAR; 
      matrix[nmanifest,1] sMANIFESTMEANS;
      matrix[nmanifest,nlatent] sLAMBDA;
      ',if(n.TDpred > 0) paste0('matrix[nlatent,ntdpred] sTDPREDEFFECT;'),'

      //ukf approximation parameters
      k = 0.5;
      a =  2.0/sqrt(nlatentpop+nlatent);
      l = a^2 * (nlatentpop + nlatent + k) - (nlatentpop+nlatent); //extra nlatent for weiner noise
      sqrtukfadjust = sqrt(nlatentpop + nlatent +l);
      
      obscount=1; //running total of observed indicators

    for(rowi in 1:ndatapoints){
      int whichobs[nobs_y[rowi]];
      int whichbinary[nbinary_y[rowi]];
      int whichcont[ncont_y[rowi]];
      whichobs = whichobs_y[rowi,1:nobs_y[rowi]]; //which obs are not missing in this row
      subjecti=subject[rowi];
      nobsi = nobs_y[rowi]; //number of obs this row

      whichbinary = whichbinary_y[rowi,1:nbinary_y[rowi]];
      whichcont = whichcont_y[rowi,1:ncont_y[rowi]];
      
      if(rowi!=1) obscount = obscount + nobs_y[rowi-1]; // number of non missing observations until now
      
      if(T0check[rowi] == 1) { // calculate initial matrices if this is first row for subjecti
      
      etaprior[rowi,] = rep_vector(0,nlatentpop+nlatent); //weiner mean 
      //etapriorcov[rowi] = rep_matrix(0, nlatentpop+nlatent,nlatentpop+nlatent);
      sigpoints = rep_matrix(0, nlatentpop+nlatent,nlatentpop+nlatent);
      ',if(ukfpop) '
      //etapriorcov[rowi,(nlatent+1):(nlatentpop),(nlatent+1):(nlatentpop)] = popcovsqrt * popcovsqrt\';
      etaprior[rowi,(nlatent+1):(nlatentpop)] = rawpopmeans[indvaryingindex];
      sigpoints[(nlatent+1):(nlatentpop),(nlatent+1):(nlatentpop)] = popcovsqrt * sqrtukfadjust;
//print("sigpoints1",sigpoints);
      ','

      sT0MEANS[,1] = T0MEANS',checkvarying(if(!stationary & nt0meansstationary ==0) 'T0MEANS' else c('T0MEANS','DRIFT','CINT'),'[subject[rowi]]','[1]'),';
      sT0VAR = T0VAR',checkvarying(if(!stationary & nt0varstationary ==0) 'T0VAR' else(c('T0VAR','DRIFT','DIFFUSION')),'[subject[rowi]]','[1]'),';
      sDRIFT = DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),';
      sDIFFUSION = DIFFUSION',checkvarying('DIFFUSION','[subject[rowi]]','[1]'),';
      sCINT[,1] = CINT',checkvarying('CINT','[subject[rowi]]','[1]'),';
      sLAMBDA = LAMBDA',checkvarying('LAMBDA','[subject[rowi]]','[1]'),';
      sMANIFESTMEANS[,1] = MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subject[rowi]]','[1]'),';
      sMANIFESTVAR = sqrt(diagonal(MANIFESTVAR',checkvarying('MANIFESTVAR','[subject[rowi]]','[1]'),'));
    ',if(n.TDpred > 0) paste0('sTDPREDEFFECT = TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subject[rowi]]','[1]'),';'),'
      
      //etaprior[rowi,1:nlatent] = T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),'; //prior for initial latent state
      ',if(n.TDpred > 0) paste0('etaprior[rowi,1:nlatent] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi] + etaprior[rowi,1:nlatent];'),'
      //etapriorcov[rowi,1:nlatent,1:nlatent] =  T0VAR',checkvarying('T0VAR','[subjecti]','[1]'),'[diffusionindices,diffusionindices];

      //set Weiner process 
      //etapriorcov[rowi,(nlatentpop+1):(nlatentpop+nlatent),(nlatentpop+1):(nlatentpop+nlatent)] = diag_matrix(rep_vector(1,nlatent)); 
      sigpoints[(nlatentpop+1):(nlatentpop+nlatent),(nlatentpop+1):(nlatentpop+nlatent)] = diag_matrix(rep_vector(1 * sqrtukfadjust,nlatent)); 

      //calculate sigma points and ukf states
      //sigpoints = cholesky_decompose(makesym(etapriorcov[rowi] * (nlatentpop + nlatent +l),.00001));
      ukfstates[2,] = etaprior[rowi]\';
      ukfstates[1,] = etaprior[rowi]\';
      ukfstates[3:((nlatentpop+nlatent)+2),] = rep_matrix(etaprior[rowi],(nlatentpop+nlatent))\' + sigpoints;
      ukfstates[((nlatentpop+nlatent)+3):((nlatentpop+nlatent)*2+2),] = rep_matrix(etaprior[rowi],(nlatentpop+nlatent))\' - sigpoints;
//print("cholesky_decompose(popcovsqrt * popcovsqrt\') * sqrtukfadjust",cholesky_decompose(popcovsqrt * popcovsqrt\') * sqrtukfadjust);
//print("sigpoints",sigpoints);
//print("ukfstates_t0",ukfstates);
      }

      ',if(!lineardynamics) paste0('
      
      for(statei in 2:((nlatent+nlatentpop)*2+2)){ //for each ukf state sample
        state = ukfstates[statei,]\';

        if(T0check[rowi]==1){
          ',paste0(t0calcs,';',collapse=' '),'
          state[1:nlatent] = sT0MEANS[,1] + sT0VAR * state[(nlatentpop+1):(nlatentpop+nlatent)];
        } 

        if(T0check[rowi]==0){
          dTsmall = dT[rowi] / integrationsteps[rowi];
          state[(nlatentpop+1):(nlatentpop+nlatent)] = state[(nlatentpop+1):(nlatentpop+nlatent)] / sqrt(dT[rowi]); //Weiner process variance adjustment
          for(stepi in 1:integrationsteps[rowi]){ //for each euler integration step
            rkstates[5] = state[1:nlatent]; //store initial states for this integration step

            for(ki in 1:4){ //runge kutta integration within euler scheme
              if(ki==2 || ki==3) state[1:nlatent]=rkstates[5] + dTsmall /2 * rkstates[ki-1];
              if(ki==4) state[1:nlatent] = rkstates[5] + dTsmall * rkstates[3];
              ',paste0(dynamiccalcs,';',collapse=' '),'
              rkstates[ki] = sDRIFT * state[1:nlatent] + sCINT[,1] +  sDIFFUSION * state[(nlatentpop+1):(nlatentpop+nlatent)];
            }
            state[1:nlatent] = (rkstates[5] + dTsmall/6  *(rkstates[1]+2*rkstates[2]+2*rkstates[3]+rkstates[4])); //integrate over rk steps
          }
        }  // end of if not t0 section (time update)

        ',paste0(dynamiccalcs,';',collapse=' '),'
        ',if(n.TDpred > 0) 'state[1:nlatent] = state[1:nlatent] + (sTDPREDEFFECT * tdpreds[rowi]); //tdpred effect only influences at observed time point','
        ukfstates[statei,1:nlatent] = state[1:nlatent]\'; //now contains time updated state
        
      }

      ukfstates[1,] = ukfstates[2,];
//if(T0check[rowi]==1) print("ukfstates tupd",ukfstates);
      etaprior[rowi,1:nlatentpop] = colMeans(ukfstates[,1:nlatentpop]);
//print("etaprior[rowi]",etaprior[rowi]);  

      etapriorcov[rowi,1:nlatentpop,1:nlatentpop] = cov_of_matrix(ukfstates[,1:nlatentpop],2*(nlatentpop+nlatent)+2, nlatentpop) / a^2;
//print("etapriorcov[rowi]",etapriorcov[rowi]);
//end nonlinear dynamics'),'


',if(lineardynamics) paste0('

  ',if(!ukfpop) paste0('
          discreteDRIFT = ',
           if(!continuoustime) paste0('sDRIFT;'),
           if(continuoustime & !driftdiagonly) paste0('matrix_exp(sDRIFT * dT[rowi]);'),
           if(continuoustime & driftdiagonly) paste0('matrix_diagexp(sDRIFT * dT[rowi]);'),'

          discreteCINT= ',
            if(!continuoustime) paste0('sCINT[,1];'),
            if(continuoustime) paste0('sDRIFT \\ (discreteDRIFT - IIlatent) * sCINT[,1];'),'

      discreteDIFFUSION = to_matrix( -(kron_prod(sDRIFT, IIlatent) + kron_prod(IIlatent,sDRIFT)) \\ to_vector(sDIFFUSION), nlatent,nlatent);
      discreteDIFFUSION = makesym(discreteDIFFUSION - quad_form(discreteDIFFUSION,discreteDRIFT\'),.00001);
      discreteDIFFUSION = cholesky_decompose(discreteDIFFUSION);
  ',collapse=''),'


        for(statei in 2:(nlatentpop+nlatent)*2+2)){ //for each ukf state sample
        state=ukfstates[statei,]\';

',if(ukfpop) paste0('
         ',paste0(dynamiccalcs,';',collapse=' '),'
          discreteDRIFT = ',
           if(!continuoustime) paste0('sDRIFT;'),
           if(continuoustime & !driftdiagonly) paste0('matrix_exp(sDRIFT * dT[rowi]);'),
           if(continuoustime & driftdiagonly) paste0('matrix_diagexp(sDRIFT * dT[rowi]);'),'

          discreteCINT= ',
            if(!continuoustime) paste0('sCINT[,1];'),
            if(continuoustime) paste0('sDRIFT \\ (discreteDRIFT - IIlatent) * sCINT[,1];'),'

      discreteDIFFUSION = to_matrix( -(kron_prod(sDRIFT, IIlatent) + kron_prod(IIlatent,sDRIFT)) \\ to_vector(sDIFFUSION), nlatent,nlatent);
      discreteDIFFUSION = makesym(discreteDIFFUSION - quad_form(discreteDIFFUSION,discreteDRIFT\'),.00001);
      discreteDIFFUSION = cholesky_decompose(discreteDIFFUSION);
'),'
          ukfstates[statei,1:nlatent] = (discreteCINT  + discreteDRIFT * state[1:nlatent] + 
             discreteDIFFUSION * state[(nlatentpop+1):(nlatentpop+nlatent)])\'; //prior for latent state of this row
          ',if(n.TDpred > 0) 'ukfstates[statei,1:nlatent]+= sTDPREDEFFECT * tdpreds[rowi];',' //tdpred effect influence
        }
      ukfstates[1,] = ukfstates[2,];
     
//end linear dynamics   '),'


      if (nobsi > 0) {  // if some observations create right size matrices for missingness and calculate...

        vector[nobsi] Y_filt;
        vector[nobsi] err;
        vector[nobsi] ypred_filt;
        matrix[2*(nlatentpop+nlatent)+2,nobsi] ukfmeasures; // expected measures based on sampled states
        matrix[nobsi, nobsi] Ypredcov_filt;
        matrix[nlatentpop, nobsi] K_filt; // kalman gain
        matrix[nobsi, nobsi] Ypredcov_filt_sqrt; 

        for(statei in 2:((nlatentpop+nlatent)*2+2)){
          state = ukfstates[statei,]\';
          ',paste0(measurementcalcs,';',collapse='  '),'
          {
            int mani;
              for(j in 1:size(whichobs)){
                mani=whichobs[j];
                if(manifesttype[mani]==0) ukfmeasures[statei,j] = sMANIFESTMEANS[mani,1] + sLAMBDA[mani,] * state[1:nlatent];
                if(manifesttype[mani]==1) ukfmeasures[statei,j] = 1/(1+exp(-(sMANIFESTMEANS[mani,1] +sLAMBDA[mani,] * state[1:nlatent])));
              }
          }
        } //end ukf update loop
        ukfmeasures[1,] = ukfmeasures[2,]; // mean goes in twice for weighting

        ypred_filt = colMeans(ukfmeasures); // ukfmeasures\' * rep_vector(1.0 / (nlatentpop*2.0+2.0), nlatentpop*2+2); //state means

        //fix binary measurement error
        sMANIFESTVAR[whichbinary] = .5^2 - square(ypred_filt[whichbinary] - .5);

       Ypredcov_filt = cov_of_matrix(ukfmeasures,2*(nlatentpop+nlatent) +2, nobsi) /a^2 + diag_matrix(sMANIFESTVAR[whichobs]);
//print("Ypredcov_filt",Ypredcov_filt);
       K_filt = mdivide_right_spd(crosscov(ukfstates[,1:nlatentpop],ukfmeasures) /a^2, Ypredcov_filt); 
//print("K_filt",K_filt);

  
      ',if(!ppchecking) 'Y_filt = Y[rowi,whichobs];','

      err = Y_filt - ypred_filt; // prediction error

      etaupd[rowi] = etaprior[rowi,1:nlatentpop] + (K_filt * err);

      etaupdcov[rowi] = makesym(etapriorcov[rowi,1:nlatentpop,1:nlatentpop] - K_filt * Ypredcov_filt * K_filt\',.00001);
//print("etaupdcov[rowi]",etaupdcov[rowi]);

      
      ',if(ppchecking) paste0('Y_filt = multi_normal_rng( MANIFESTMEANS',
        checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs] + sLAMBDA[whichobs,] * etaprior[rowi], Ypredcov_filt);'),'
      
      ',if(1==99 & binomial & ppchecking) paste0('for(obsi in 1:nobsi) Y_filt[obsi] = bernoulli_rng(inv_logit(sLAMBDA[whichobs,] * etaupd[rowi] + ', 
        'MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs])[obsi]);'),'

      ',if(any(manifesttype==1)) 'll = ll+sum(log( Y_filt[whichbinary] .* (ypred_filt[whichbinary]) + (1-Y_filt[whichbinary]) .* (1-ypred_filt[whichbinary])));',' 
      ',if(any(manifesttype==0)) '
         Ypredcov_filt_sqrt=cholesky_decompose(makesym(Ypredcov_filt[whichcont,whichcont],.00001));
         ll = ll+normal_lpdf(mdivide_left_tri_low(Ypredcov_filt_sqrt, err[whichcont])|0,1); //transform pred errors to standard normal dist and collect
      ll = ll+sum(-log(diagonal(Ypredcov_filt_sqrt[whichcont,whichcont]))); //account for transformation of scale in loglik ','

//print("ukfstates1",ukfstates);
      {
      vector[nlatentpop] updatesigpoints;
      matrix[nlatentpop,nlatentpop] etaupdchol;

//print("etaupdcov", etapriorcov[rowi] - K_filt * Ypredcov_filt * K_filt\');
      etaupdchol = cholesky_decompose(etaupdcov[rowi]) * sqrtukfadjust;


      for(statei in 1:((nlatentpop+nlatent)*2+2)){
       updatesigpoints = rep_vector(0,nlatentpop); 
        if(statei > 2 && statei < (3+nlatentpop)) updatesigpoints = etaupdchol[,statei-2];
        if(statei > (2+nlatentpop+nlatent) && statei < (3+nlatentpop+nlatent+nlatentpop)) updatesigpoints = -etaupdchol[,statei-2-nlatentpop-nlatent];
        ukfstates[statei,1:nlatentpop] = (etaupd[rowi] + updatesigpoints)\';
        //ukfstates[statei,1:nlatentpop] = ukfstates[statei,1:nlatentpop] + (K_filt[,1:nlatentpop] * (ypred_filt-Y_filt))\'; //(etaupd[rowi] + updatesigpoints)\';
      } //end ukf update loop
//print("ukfstates_mupd",ukfstates);
}

      //etaupd[rowi] = etaprior[rowi] + (K_filt * err);
      
//print("etaupdcov[rowi]",(cov_of_matrix(ukfstates,2*(nlatentpop+nlatent)+2, nlatentpop+nlatent) / a^2) - K_filt * Ypredcov_filt * K_filt\');
//print("K_filt * Ypredcov_filt * K_filt\'",K_filt * Ypredcov_filt * K_filt\');;
//print("etaupd[rowi]",etaupd[rowi]);
//print("cov_of_matrix", cov_of_matrix(ukfstates,2*nlatentpop +2, nlatentpop));
//print("colMeans", colMeans(ukfstates));

    ',if(verbose & 1==2) verbosefilter() ,'
      }
      }

     // ll = ll+normal_lpdf(errtrans|0,1); 
      //ll= ll - sum(errscales);
      }
      ')
    return(out)
   }
   
  
      
      subjectparaminit<- function(){
paste0('      matrix[nlatent,nlatent] DIFFUSION',checkvarying('DIFFUSION','[nsubjects]','[1]'),'; //additive latent process variance
          matrix[nlatent,nlatent] T0VAR',checkvarying(if(!stationary & nt0varstationary ==0) 'T0VAR' else(c('T0VAR','DRIFT','DIFFUSION')),'[nsubjects]','[1]'),'; //initial latent process variance
          ',if(!kalman)  paste0('matrix[nlatent,nlatent] T0VARsqrt',checkvarying('T0VAR','[nsubjects]','[1]'),'; //initial latent process variance'),'
          matrix[nlatent,nlatent] DRIFT',checkvarying('DRIFT','[nsubjects]','[1]'),'; //dynamic relationships of processes
          ',if(!binomial) paste0('matrix[nmanifest,nmanifest] MANIFESTVAR',checkvarying('MANIFESTVAR','[nsubjects]','[1]'),'; // manifest error variance'),'
          vector[nmanifest] MANIFESTMEANS',checkvarying('MANIFESTMEANS','[nsubjects]','[1]'),';
          vector[nlatent] T0MEANS',checkvarying(if(!stationary & nt0meansstationary ==0) 'T0MEANS' else c('T0MEANS','DRIFT','CINT'),'[nsubjects]','[1]'),'; // initial (T0) latent states
          matrix[nmanifest,nlatent] LAMBDA',checkvarying('LAMBDA','[nsubjects]','[1]'),'; // loading matrix
          vector[nlatent] CINT',checkvarying('CINT','[nsubjects]','[1]'),'; // latent process intercept
          ',if(nt0meansstationary > 0) paste0('vector[nlatent] asymCINT',checkvarying(c('DRIFT','CINT'),'[nsubjects]','[1]'),'; // latent process asymptotic level'),'
          ',if(!asymdiffusion) paste0('matrix[ndiffusion,ndiffusion] asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),'; //latent process variance as time interval goes to inf'),'
          
          ',if(n.TDpred > 0) paste0('matrix[nlatent,ntdpred] TDPREDEFFECT',checkvarying('TDPREDEFFECT','[nsubjects]','[1]'),'; // effect of time dependent predictors'),'
          ',if(n.TIpred > 0) paste0('
          matrix[',nindvarying,',',n.TIpred,'] tipredeffect; //design matrix of individual time independent predictor effects ')
)
      }
      
      subjectparamcalc<-function(){
        paste0('{
          vector[ndiffusion*ndiffusion] asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),';
          ',if(continuoustime & !asymdiffusion) paste0('matrix[ndiffusion*ndiffusion,ndiffusion*ndiffusion] DRIFTHATCH',checkvarying(c('DRIFT'),'[nsubjects]','[1]'),';'),'
          
          // create subject specific parameter matrices from fixed and transformed free effects 
          ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi) {
          
          x<-paste0( #left side - which matrix element
          checkvarying(ctspec[rowi,'matrix'],'for(subi in 1:nsubjects) '),
          ctspec[rowi,'matrix'], checkvarying(ctspec[rowi,'matrix'],'[subi]','[1]'),'[', ctspec[rowi,'row'], 
            if(ctspec[rowi,'matrix'] %in% c('LAMBDA','DRIFT','DIFFUSION',
            'MANIFESTVAR', 'TDPREDEFFECT', 'T0VAR')) paste0(' , ', ctspec[rowi,'col']),
            ']') 
          
          y<- paste0('(', #right side - using popmean or indparam? and which?
            if(is.na(ctspec[rowi,'value']) & (!ctspec$indvarying[rowi] | ukfpop)) paste0('rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
            if(ctspec[rowi,'indvarying'] & !ukfpop) paste0('indparams[subi,',which(ctspec[ctspec$indvarying,'param']==ctspec[rowi,'param']),']')
            ,')')
          
          #right side if fixed value
          if(!is.na(ctspec[rowi,'value'])) out<-paste0(x,' = ',ctspec[rowi,'value'],'; \n')
          
          #transform right side if appropriate
          if(!is.na(ctspec$transform[rowi]) & is.na(ctspec$value[rowi])) out<-paste0(
          x, ' = ', gsub('param',y,ctspec$transform[rowi]),'; \n')
          return(out)
        })),collapse=''),
          
          '
          // create subject specific parameter matrices from duplicated transformed free effects 
          ',if(nrow(ctspecduplicates)>0) paste0(unlist(lapply(1:nrow(ctspecduplicates),function(rowi) {
          
          x<-paste0( #left side - which matrix element
          checkvarying(ctspecduplicates[rowi,'matrix'],'for(subi in 1:nsubjects) '),
          ctspecduplicates[rowi,'matrix'], checkvarying(ctspecduplicates[rowi,'matrix'],'[subi]','[1]'),'[', ctspecduplicates[rowi,'row'], 
            if(ctspecduplicates[rowi,'matrix'] %in% c('LAMBDA','DRIFT','DIFFUSION',
            'MANIFESTVAR', 'TDPREDEFFECT', 'T0VAR')) paste0(' , ', ctspecduplicates[rowi,'col']),
            ']') 
          
          y<- paste0('(', #right side - using popmean or indparam? and which?
            if(is.na(ctspecduplicates[rowi,'value']) & (!ctspecduplicates$indvarying[rowi])) ctspecduplicates$popmeanduplicates[rowi],
            if(ctspecduplicates[rowi,'indvarying']) paste0('indparams[subi,',
              which(
              ctspec[ctspec$indvarying,'param']==ctspecduplicates[rowi,'param'] ),
              ']')
            ,')')
          
          #transform right side if appropriate
          if(!is.na(ctspecduplicates$transform[rowi]) & is.na(ctspecduplicates$value[rowi])) out<-paste0(
          x, ' = ', gsub('param',y,ctspecduplicates$transform[rowi]),'; \n')
          return(out)
      })),collapse=''),
          '
          
          
          // perform any whole matrix transformations 
          
          
          for(individual in 1:',checkvarying('DIFFUSION','nsubjects','1'),') DIFFUSION[individual] = sdcovsqrt2cov(DIFFUSION[individual],ukfpop);
          
          ',if(continuoustime) paste0('
          for(individual in 1:',checkvarying('DRIFT','nsubjects','1'),') {
            ',if(!asymdiffusion) paste0(
            'DRIFTHATCH[individual] = kron_prod(DRIFT[individual,diffusionindices,diffusionindices],diag_matrix(rep_vector(1, ndiffusion))) +  ',
            'kron_prod(diag_matrix(rep_vector(1, ndiffusion)),DRIFT[individual,diffusionindices,diffusionindices]);
            '),'
          }
          
          ',if(!asymdiffusion) paste0('
          for(individual in 1:',checkvarying(c('DIFFUSION','DRIFT'),'nsubjects','1'),'){
            asymDIFFUSIONvec[individual] =  -(DRIFTHATCH',checkvarying(c('DRIFT'),'[individual]','[1]'),
              ' \\ to_vector(DIFFUSION',checkvarying(c('DIFFUSION'),'[individual]','[1]'),
                '[diffusionindices,diffusionindices]));
            
            for(drowi in 1:ndiffusion) {
              for(dcoli in 1:ndiffusion){
                asymDIFFUSION[individual,drowi,dcoli] =  asymDIFFUSIONvec[individual,drowi+(dcoli-1)*ndiffusion];
              }}
            asymDIFFUSION[individual] = makesym(asymDIFFUSION[individual],.00001);
          }
          ')),
          
          if(!continuoustime & !asymdiffusion) paste0('
          for(individual in 1:',checkvarying(c('DIFFUSION','DRIFT'),'nsubjects','1'),'){
            asymDIFFUSIONvec[individual] = (IIlatent2 - kron_prod(DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),', DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),')) * 
              to_vector(DIFFUSION',checkvarying(c('DIFFUSION'),'[individual]','[1]'),');
            for(drowi in 1:nlatent) {
              for(dcoli in 1:nlatent){
                asymDIFFUSION[individual,drowi,dcoli] =  asymDIFFUSIONvec[individual,drowi+(dcoli-1)*nlatent];
              }}
          }
          '),'
          
          
          ',if(nt0meansstationary > 0 & continuoustime) paste0('
          for(individual in 1:',checkvarying(c('CINT','DRIFT'),'nsubjects','1'),'){
            asymCINT[individual] =  -DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),
            ' \\ CINT',checkvarying(c('CINT'),'[individual]','[1]'),';
          }
          '),
          
          if(nt0meansstationary > 0 & !continuoustime) paste0('
          for(individual in 1:',checkvarying(c('CINT','DRIFT'),'nsubjects','1'),'){
            asymCINT[individual] =  (latentII - DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),
              ') \\ CINT',checkvarying(c('CINT'),'[individual]','[1]'),';
          }
          '),'
          
          
          ',if(!binomial) paste0(
          'for(individual in 1:',checkvarying('MANIFESTVAR','nsubjects','1'),') {
            MANIFESTVAR[individual] = square(MANIFESTVAR[individual]);
            //MANIFESTVAR[individual] = asymDIFFUSION[individual] .* MANIFESTVAR[individual] ;
          }
          '),'
          
          
          for(individual in 1:',
            checkvarying(if(!stationary & nt0varstationary==0) 'T0VAR' else(c('T0VAR','DRIFT','DIFFUSION')),'nsubjects','1'),') {
            T0VAR[individual] = ',
            if(!stationary) paste0('sdcovsqrt2cov(T0VAR[individual],ukfpop);'),
            if(stationary) paste0(if(!asymdiffusion) 'asym', 'DIFFUSION',
            checkvarying(c('DRIFT','DIFFUSION'),'[individual]','[1]'),';'),'
            ',if(!kalman) 'T0VARsqrt[individual] = cholesky_decompose(T0VAR[individual]);',
            'if(nt0varstationary > 0) for(rowi in 1:nt0varstationary){
              T0VAR[individual,t0varstationary[rowi,1],t0varstationary[rowi,2] ] = 
                asymDIFFUSION[individual,t0varstationary[rowi,1],t0varstationary[rowi,2] ];
              T0VAR[individual,t0varstationary[rowi,2],t0varstationary[rowi,1] ] = 
                asymDIFFUSION[individual,t0varstationary[rowi,2],t0varstationary[rowi,1] ];
          }
          }
          
          for(individual in 1:',
            checkvarying(if(!stationary & nt0meansstationary==0) 'T0MEANS' else(c('T0MEANS','DRIFT','CINT')),'nsubjects','1'),') {
            ',if(stationary) paste0('T0MEANS[individual] = -DRIFT', checkvarying('DRIFT','[individual]','[1]'),
            ' \\ CINT',checkvarying('CINT','[individual]','[1]'),'; // prior for initial latent states is stationary mean'),'
            ',if(nt0meansstationary > 0) paste0('if(nt0meansstationary > 0) for(rowi in 1:nt0meansstationary){
              T0MEANS[individual,t0meansstationary[rowi,1]] = 
                asymCINT',checkvarying(c('DRIFT','CINT'),'[individual]','[1]'),'[t0meansstationary[rowi,1]];
            }'),'
            }
          
          }
        
        ',if(nonexplosive) paste0('
        // non explosive priors
        for(individual in 1:',checkvarying(c('DRIFT','DIFFUSION'),'nsubjects','1'),'){
          dets[individual]= determinant(asymDIFFUSION[individual]);
        }
        detpenalty = sum(-log( 1-(inv_logit(-dets) .* (dets))+1)) / ',checkvarying(c('DRIFT'),'nsubjects','1'),';
        ') )
      }

  writemodel<-function(init=FALSE,nopriors=FALSE){
    stanmodel <- paste0('
      functions{

matrix matrix_diagexp(matrix in){
matrix[rows(in),rows(in)] out;
for(i in 1:rows(in)){
for(j in 1:rows(in)){
if(i==j) out[i,i] = exp(in[i,i]);
if(i!=j) out[i,j] = 0;
}}
return out;
}

matrix trisolve(matrix l, int unitdiag){ //inverse of triangular matrix
  matrix[rows(l),rows(l)] b ;
  matrix[rows(l),rows(l)] x;
  x = diag_matrix(rep_vector(1,rows(l)));
  b = x;

    for(j in 1:cols(x)){
      if(unitdiag != 1) x[j,j] = b[j,j] / l[1,1];
      
     if(rows(x)>1){
      for(m in 2:rows(x)){
      x[m,j]  =  (b[m,j] - (l[m,1:(m-1)] * x[1:(m-1),j]) ) / l[m,m];
      }
     }
    }
  return x;
}

matrix inverse_sym(matrix a){ // use ldlt decomposition to decompose symmetric non-definite matrices
  matrix[rows(a),rows(a)] d;
  matrix[rows(a),rows(a)] l;

  d=diag_matrix(rep_vector(0,rows(a)));
  l=diag_matrix(rep_vector(1,rows(a)));
  
  for(j in 1:rows(a)){
    for(i in (min(j+1,rows(a))):rows(a)){
      
      if(j==1) {
        d[j,j]=a[j,j];
        l[i,j]=1/d[j,j] * a[i,j];
      }
      if(j>1) {
        d[j,j]=a[j,j]- sum( square(l[j, 1:(j-1)]) * d[1:(j-1), 1:(j-1)]);
        if(i > j) l[i,j]=1/d[j,j] * ( a[i,j] - sum(l[i,1:(j-1)] .* l[j,1:(j-1)] * d[1:(j-1),1:(j-1)]));
      }
    }
  }
  l = trisolve(l,0);
  l = l\' * diag_matrix(rep_vector(1,rows(d)) ./ diagonal(d)) * l;
  return l;
}


 matrix covsqrt2corsqrt(matrix mat, int invert){ //converts from lower partial sd matrix to cor
      matrix[rows(mat),cols(mat)] o;
      vector[rows(mat)] s;
    o=mat;

    for(i in 1:rows(o)){ //set upper tri to lower
for(j in min(i+1,rows(mat)):rows(mat)){
o[j,i] = inv_logit(o[j,i])*2-1;  // can change cor prior here
o[i,j] = o[j,i];
}
      o[i,i]=1; // change to adjust prior for correlations
    }

if(invert==1) o = inverse_sym(o);


  for(i in 1:rows(o)){
      s[i] = inv_sqrt(o[i,] * o[,i]);
    if(is_inf(s[i])) s[i]=0;
    }
      o= diag_pre_multiply(s,o);
return o;
 }

      matrix sdcovsqrt2cov(matrix mat, int cholesky){ //converts from lower partial sd and diag sd to cov or cholesky cov
      matrix[rows(mat),rows(mat)] out;
      int invert;

invert = 0; //change integer for marginal or partial prior
if(rows(mat) > 1){
      out=covsqrt2corsqrt(mat,invert); 
      out= diag_pre_multiply(diagonal(mat), out);
}
if(rows(mat)==1) out[1,1] = mat[1,1];

      if(cholesky==0) out = out * out\';
      return(out);
      }
      

      matrix kron_prod(matrix mata, matrix matb){
      int m;
      int p;
      int n;
      int q;
      matrix[rows(mata)*rows(matb),cols(mata)*cols(matb)] C;
      m=rows(mata);
      p=rows(matb);
      n=cols(mata);
      q=cols(matb);
      for (i in 1:m){
      for (j in 1:n){
      for (k in 1:p){
      for (l in 1:q){
      C[p*(i-1)+k,q*(j-1)+l] = mata[i,j]*matb[k,l];
      }
      }
      }
      }
      return C;
      }
      
      matrix makesym(matrix mat, real ridge){
      matrix[rows(mat),cols(mat)] out;
      out=mat;
      for(rowi in 1:rows(mat)){
      for(coli in 1:cols(mat)){
      if(coli > rowi) {
out[rowi,coli]= (mat[coli,rowi] + mat[rowi,coli]) *.5;
out[coli,rowi] = out[rowi,coli];

      }
if(rowi==coli) out[rowi,coli]= out[rowi,coli] +ridge;
      }
      }
      return out;
      }
      
      matrix cov(vector[] mat,int nrows,int ncols){
      vector[ncols] means;
      matrix[nrows,ncols] centered;
      matrix[ncols,ncols] covm;
      for (coli in 1:ncols){
      means[coli] = mean(mat[,coli]);
      for (rowi in 1:nrows)  {
      centered[rowi,coli] = mat[rowi,coli] - means[coli];
      }
      }
      covm = centered\' * centered / (nrows-1);
      return covm; 
      }

      matrix cov_of_matrix(matrix mat,int nrows,int ncols){
      vector[ncols] means;
      matrix[nrows,ncols] centered;
      matrix[ncols,ncols] covm;
      for (coli in 1:ncols){
      means[coli] = mean(mat[,coli]);
      for (rowi in 1:nrows)  {
      centered[rowi,coli] = mat[rowi,coli] - means[coli];
      }
      }
      covm = centered\' * centered / (nrows-1);
      return covm; 
      }

vector colMeans(matrix mat){
  vector[cols(mat)] out;
  for(i in 1:cols(mat)){
    out[i] = mean(mat[,i]);
  }
  return out;
}

matrix crosscov(matrix a, matrix b){
  matrix[rows(a),cols(a)] da;
  matrix[rows(b),cols(b)] db;
  matrix[cols(a),cols(b)] out;

  da = a - rep_matrix( (colMeans(a))\',rows(a));
  db = b - rep_matrix( (colMeans(b))\',rows(b));
  out = da\' * db ./ (rows(a)-1.0);
  return out;
}


      }
      
      data {
      int<lower=0> ndatapoints;
      int<lower=1> nmanifest;
      int<lower=1> nlatent;
      int<lower=1> nsubjects;
      
      ',if(n.TIpred > 0) paste0('int<lower=0> ntipred; // number of time independent covariates
        matrix[nsubjects,ntipred] tipredsdata;
        int nmissingtipreds;'),'
      
      ',if(!binomial) 'vector[nmanifest] Y[ndatapoints]; \n',
      if(binomial) 'int Y[ndatapoints,nmanifest]; \n','
      int<lower=0> ntdpred; // number of time dependent covariates
      
      ',if(n.TDpred > 0) paste0('vector[ntdpred] tdpreds[ndatapoints];'),'
      
      vector[ndatapoints] dT; // time intervals
      int integrationsteps[ndatapoints] ; // time steps needed between time intervals for integration
      int driftindex[ndatapoints]; //which discreteDRIFT matrix to use for each time point
      int diffusionindex[ndatapoints]; //which discreteDIFFUSION matrix to use for each time point
      int cintindex[ndatapoints]; //which discreteCINT matrix to use for each time point
      int subject[ndatapoints];
      int<lower=0> nparams;
      int T0check[ndatapoints]; // logical indicating which rows are the first for each subject
      int continuoustime; // logical indicating whether to incorporate timing information
      int nindvarying; // number of subject level parameters that are varying across subjects
      int nindvaryingoffdiagonals; //number of off diagonal parameters needed for popcov matrix
      int notindvaryingindex[nparams-nindvarying];
      ',if(nindvarying>0) paste0('int indvaryingindex[nindvarying];
        vector[nindvarying] sdscale;'),'
      
      ',if(!is.na(ctstanmodel$stationarymeanprior)) 'vector[nlatent] stationarymeanprior; // prior std dev for difference between process asymptotic mean and initial mean','
      ',if(!is.na(ctstanmodel$stationaryvarprior)) 'vector[nlatent] stationaryvarprior; // prior std dev for difference between process asymptotic variance and initial variance','

      int nt0varstationary;
      int nt0meansstationary;
      int t0varstationary [nt0varstationary, 2];
      int t0meansstationary [nt0meansstationary, 2];
      
      int<lower = 0, upper = nmanifest> nobs_y[ndatapoints];  // number of observed variables per observation
      int<lower = 0, upper = nmanifest> whichobs_y[ndatapoints, nmanifest]; // index of which variables are observed per observation
      int<lower=0,upper=nlatent> ndiffusion; //number of latents involved in covariance calcs
      int<lower=0,upper=nlatent> diffusionindices[ndiffusion]; //index of which latent variables are involved in covariance calculations

      int manifesttype[nmanifest];
      int<lower = 0, upper = nmanifest> nbinary_y[ndatapoints];  // number of observed binary variables per observation
      int<lower = 0, upper = nmanifest> whichbinary_y[ndatapoints, nmanifest]; // index of which variables are observed and binary per observation
      int<lower = 0, upper = nmanifest> ncont_y[ndatapoints];  // number of observed continuous variables per observation
      int<lower = 0, upper = nmanifest> whichcont_y[ndatapoints, nmanifest]; // index of which variables are observed and continuousper observation
      
      int ukfpop;
}
      
      transformed data{
      matrix[nlatent,nlatent] IIlatent;
      matrix[nlatent*nlatent,nlatent*nlatent] IIlatent2;
      int nlatentpop;

      nlatentpop = ',ifelse(ukfpop,'nlatent + nindvarying;','nlatent;'),'
      IIlatent = diag_matrix(rep_vector(1,nlatent));
      IIlatent2 = diag_matrix(rep_vector(1,nlatent*nlatent));
      }
      
      parameters {
      vector[nparams] rawpopmeans',if(!estpop) 'base','; // population level means \n','
      
      ',if(any(indvarying)) paste0(
        'vector',if(!is.na(ctstanmodel$rawpopsdbaselowerbound)) paste0('<lower=',ctstanmodel$rawpopsdbaselowerbound[1],'>'),'[nindvarying] rawpopsdbase; //population level std dev
        //cholesky_factor_corr[nindvarying] rawpopcorrsqrt; // population level correlation square root
        //cov_matrix[nindvarying] wishmat;
        vector[nindvaryingoffdiagonals] sqrtpcov;
        '),if(any(indvarying) & !ukfpop) 'vector[nindvarying*nsubjects] rawindparams; //subject level parameters','
      
      ',if(n.TIpred > 0) paste0('
        vector[',sum(unlist(ctspec[,paste0(TIpredNames,'_effect')])),'] tipredeffectparams; // effects of time independent covariates
        vector[nmissingtipreds] tipredsimputed; \n'),'
      
      ',if(!kalman)  'vector[nlatent*ndatapoints] etaupdbase; //sampled latent states posterior','
      
      
      }
      
      transformed parameters{
      ',if(!estpop) 'vector[nparams] rawpopmeans;','

',if(nonexplosive) paste0('
        vector[',checkvarying(c('DRIFT'),'nsubjects','1'),'] dets;
        real detpenalty;
'),'

      ',if(nindvarying > 0 & !ukfpop) 'vector[nindvarying] indparams[nsubjects];','
      ',if(nindvarying > 0) paste0('
        vector[nindvarying] rawpopsd; //population level std dev',
          if(estpop) paste0(' 
        matrix[nindvarying,nindvarying] sqrtpcovmat;
        matrix[nindvarying,nindvarying] rawpopcorrsqrt;
        matrix[nindvarying,nindvarying] popcovsqrt; '),'
        ',if(!estpop) paste0('matrix[nindvarying,nindvarying] mlcov;
            vector[nindvarying] rawindparamsarray[nsubjects]; ')),'
      
        ',if(!ukfpop) subjectparaminit(),'
      
      ',if(n.TIpred > 0) paste0('
        matrix[nsubjects,ntipred] tipreds; //tipred values to fill from data and, when needed, imputation vector
      {
      int counter;
      counter = 0;
      for(rowi in 1:rows(tipreds)){
        for(coli in 1:cols(tipreds)){
          if(tipredsdata[rowi,coli]==99999) {
            counter = counter + 1;
            tipreds[rowi,coli] = tipredsimputed[counter];
          } else tipreds[rowi,coli] = tipredsdata[rowi,coli];
        }
        }
      }
      '),

if(n.TIpred > 0) paste0(unlist(lapply(1,function(x){ ## collects all the time independent predictors effects into the design matrix
        count<-0
        tirow<-0
        out<-c()
        for(rowi in 1:nrow(ctspec[,])){
          if(is.na(ctspec$value[rowi]) & ctspec$indvarying[rowi]) {
            tirow<-tirow+1
            for(predi in 1:n.TIpred){
              if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == FALSE) out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = 0; \n')
              if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == TRUE) {
                count<-count+1
                out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = tipredeffectparams[',count,']; \n ')
              }
            }
          }}
        return(out)
      })),collapse=''),'

  
      ',if(any(indvarying) & estpop) paste0('
        rawpopsd = ',ctstanmodel$rawpopsdtransform, ';
{
int counter;
sqrtpcovmat=diag_matrix(rep_vector(-99,nindvarying));
if(nindvarying > 1){
counter=0;
        for(j in 1:(nindvarying-1)){
        for(i in (j+1):nindvarying){
counter=counter+1;
        sqrtpcovmat[i,j]=sqrtpcov[counter];
        }}
}
}

if(nindvarying > 1) rawpopcorrsqrt = covsqrt2corsqrt(sqrtpcovmat,0); //change int to change from partial to marginal prior


',if(1==99) '
if(nindvarying >1)rawpopcorrsqrt = cholesky_decompose(quad_form_diag(wishmat, inv_sqrt( diagonal(wishmat))));
','

if(nindvarying ==1) rawpopcorrsqrt = diag_matrix(rep_vector(1,1));

        popcovsqrt= diag_pre_multiply(rawpopsd, rawpopcorrsqrt);
        
        ',if(!ukfpop) paste0('for(subi in 1:nsubjects) {
        indparams[subi]= 
        ',if(noncentered) 'popcovsqrt * ',
          'rawindparams[(1+(subi-1)*nindvarying):(subi*nindvarying)] + rawpopmeans[indvaryingindex] ',
        if(n.TIpred>0) ' + tipredeffect * tipreds[subi]\' ',
        ';  
        }'),'
        '),

      
if(!estpop) paste0('
rawpopmeans=rawpopmeansbase;
for(subi in 1:nsubjects) {
  rawindparamsarray[subi]= rawindparams[(1+(subi-1)*nindvarying):(subi*nindvarying)];
indparams[subi]= rawindparamsarray[subi]+rawpopmeans[indvaryingindex];
  }
  mlcov = cov(rawindparamsarray,nsubjects,nindvarying) + diag_matrix(rep_vector(.000001,nindvarying));
  rawpopsd=sqrt(diagonal(mlcov));
  for(pari in 1:nindvarying){
  rawpopmeans[indvaryingindex[pari]]=mean(indparams[,pari]);
  }
  '),
if(!ukfpop) subjectparamcalc(),'

      

      }
      
      model{
      real ll;
      ',if(!nopriors) paste0('target += normal_lpdf(rawpopmeans|0,1);'),'
      
      ',if(n.TIpred > 0 & !nopriors) paste0('
        tipredeffectparams ~ ',ctstanmodel$tipredeffectprior, '; 
        tipredsimputed ~ ',ctstanmodel$tipredsimputedprior,';\n '),' 
      
      ',if(any(ctspec$indvarying) & !nopriors) paste0(
        
        if(estpop) paste0('
        //rawpopcorrsqrt ~ lkj_corr_cholesky(.1); 
        if(nindvarying >1) sqrtpcov ~ normal(0,1);
        //wishmat ~ inv_wishart(nindvarying,diag_matrix(rep_vector(1,nindvarying)));
        ',if(noncentered & !ukfpop) paste0('rawindparams ~ normal(0,1);'),' 
        ',if(!noncentered & !ukfpop) paste0('target += multi_normal_lpdf(indparams|rawpopmeans[indvaryingindex],popcovsqrt * popcovsqrt\');'),' 
        rawpopsdbase ~ ',ctstanmodel$rawpopsdbase,';'),
        
        if(!estpop) 'target += multi_normal_lpdf(rawindparamsarray| rep_vector(0,nindvarying), mlcov);','
        '),'
      
      ',if(!kalman) 'etaupdbase ~ normal(0,1); \n','
      
      ll = 0;

   ',if(!binomial & 99==1) paste0(
     'for(individual in 1:',checkvarying(c('MANIFESTVAR','DIFFUSION','DRIFT'),'nsubjects','1'),') {
    diagonal(asymDIFFUSION[individual]) ./ (diagonal(MANIFESTVAR[individual]) + diagonal(asymDIFFUSION[individual])) ~  beta(2,2); 
  }'),'
      
      // adjust partial correlation probabilities (not presently used)
      ',if(!nopriors) paste0(unlist(lapply(1:nrow(ctspec),function(rowi) {
        out<-''
        if(ctspec$matrix[rowi] %in% c('T0VAR','DIFFUSION') & ctspec$row[rowi] > ctspec$col[rowi] & is.na(ctspec$value[rowi])) {
          out=paste0('//target += beta_lpdf(inv_logit(',
            'rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']',
            ')| 1.5 + (inttoreal(nlatent)-1)/2 - .6 * ',ctspec$col[rowi],', 1.5 + (inttoreal(nlatent)-1)/2 - .6 * ',ctspec$col[rowi],'); \n ')
        }
        return(out)
      })),collapse=''),'

',if(nonexplosive) '
    // non explosive priors - converging to stationary
target +=  detpenalty;
','
      
      ',if(!is.na(ctstanmodel$stationaryvarprior)) paste0('
        // stationarity priors
        for(individual in 1:nsubjects) {
        (diagonal(',
        if(!asymdiffusion) 'asym', 'DIFFUSION[',
        checkvarying(c('DIFFUSION','DRIFT'),'individual','1'),']) - diagonal(T0VAR[',
        checkvarying('T0VAR','individual','1'),',diffusionindices,diffusionindices])) ~ normal(0,stationaryvarprior); // variance stationarity prior
        }
        '),'
      
      ',if(!is.na(ctstanmodel$stationarymeanprior)) paste0('
        for(individual in 1:nsubjects) {
        T0MEANS[',checkvarying('T0MEANS','individual','1'),'] - ',
        '( DRIFT[',checkvarying('DRIFT','individual','1'),'] \\ CINT[',checkvarying('CINT','individual','1'),'] )',
        ' ~ normal(0,stationarymeanprior); // mean stationarity prior
        }
        '),

      

if(ukfpop) paste0('
{
  int nsubjectsisone;
  nsubjectsisone = 1;
  {
  ',gsub('nsubjects','nsubjectsisone',subjectparaminit(),fixed=TRUE),
  gsub('nsubjects','nsubjectsisone',subjectparamcalc(),fixed=TRUE),
  gsub('subject[rowi]','1', ifelse(ukf, ukfilterfunc(ppchecking=FALSE), filteringfunc(ppchecking=FALSE)), fixed=TRUE),'
  }
}'),

if(!ukfpop) ifelse(ukf, ukfilterfunc(ppchecking=FALSE), filteringfunc(ppchecking=FALSE)),'

      target += ll;
      
      
      ',if(verbose) paste0('
        print("lp = ", target());
        '),'
      
        }
      generated quantities{
      ',if(nindvarying > 1 & estpop) paste0('matrix[nindvarying,nindvarying] rawpopcorr;'),'
      
      ',paste0('real hmean_',ctspec$param[is.na(ctspec$value)],'; \n',collapse=''),'
      
      ',if(nindvarying > 0) paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(ctspec$indvarying[rowi]) paste0('real hsd_',ctspec$param[rowi],'; \n')
      })),collapse=''),'

      ',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
        paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
          if(ctspec$indvarying[rowi] & 
              ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('real tipred_',
                TIpredNames[tip], '_on_', ctspec$param[rowi],'; \n'
              )
        })),collapse='')
        })),collapse=''),'

      ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(is.na(ctspec$value[rowi])) paste0('hmean_',ctspec$param[rowi],' = ',
          gsub('param',
            paste0('rawpopmeans[',
              which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),
              ']'),
            ctspec$transform[rowi]),'; \n')
      })),collapse=''),'

     ',if(nindvarying > 1 &estpop) paste0(' rawpopcorr = rawpopcorrsqrt * rawpopcorrsqrt\';'),'
      
      ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(ctspec$indvarying[rowi]) paste0('hsd_',ctspec$param[rowi],' = ',
          'rawpopsd[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),']; \n',
          if(!is.na(ctspec$transform[rowi])) paste0(
            'hsd_',ctspec$param[rowi],' = ( (fabs
            ((', 
            gsub('param', paste0('(rawpopmeans[',
              which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),
              '] + hsd_',
              ctspec$param[rowi],')'),ctspec$transform[rowi]), ') - (',
            gsub('param', 
              paste0('(rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),
                '] -  hsd_',
                ctspec$param[rowi],')'),ctspec$transform[rowi]),'))/2) +
            (fabs
            ((', 
            gsub('param', paste0('(rawpopmeans[',
              which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),
              '] + 3 * hsd_',
              ctspec$param[rowi],')'),ctspec$transform[rowi]), ') - (',
            gsub('param', 
              paste0('(rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),
                '] - 3 * hsd_',
                ctspec$param[rowi],')'),ctspec$transform[rowi]),'))/6) ) /2
            ; \n')
            )
      })),collapse=''),'

      
      ',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
        paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
          if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('
            tipred_',TIpredNames[tip], '_on_', ctspec$param[rowi],' = ',
            'tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']; \n',
            if(!is.na(ctspec$transform[rowi])) paste0('tipred_', TIpredNames[tip], '_on_', ctspec$param[rowi],' = ((', 
              gsub('param', 
                paste0('rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
                ctspec$transform[rowi]), 
              ') - (',
              gsub('param', 
                paste0('rawpopmeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
                ctspec$transform[rowi]),'))/2; \n')
          )
        })),collapse='')
      })),collapse=''),'

      }')
    }
  
  if(is.na(stanmodeltext)) stanmodeltext<-writemodel(init=initwithoptim,nopriors= nopriors)

  # out<-list(stanmodeltext=stanmodeltext)
  
  standata<-list(
    Y=cbind(as.matrix(datalong[,manifestNames])),
    subject=datalong[,idName],
    idmap=idmap,
    nsubjects=nsubjects,
    nmanifest=n.manifest,
    integrationsteps=integrationsteps,
    T0check=T0check,
    indvaryingindex=indvaryingindex,
    notindvaryingindex=array(which(ctspec$indvarying[is.na(ctspec$value)] == FALSE),dim=nparams-nindvarying),
    continuoustime=sum(continuoustime),
    nlatent=n.latent,
    ntipred=n.TIpred,
    ntdpred=n.TDpred,
    nparams=nparams,
    nindvarying=nindvarying,
    nindvaryingoffdiagonals = (nindvarying*nindvarying-nindvarying)/2,
    sdscale=array(ctspec$sdscale[ctspec$indvarying]),
    IIparams = diag(nparams),
    ndatapoints=nrow(datalong),
    dT=dT,
    time=datalong[,timeName],
    driftindex=driftindex,
    cintindex=cintindex,
    nt0varstationary=nt0varstationary,
    nt0meansstationary=nt0meansstationary,
    t0varstationary=matrix(as.numeric(t0varstationary),ncol=2),
    t0meansstationary=matrix(as.numeric(t0meansstationary),ncol=2),
    diffusionindex=diffusionindex,
    diffusionindices=array(diffusionindices,dim=ndiffusion),
    ndiffusion=ndiffusion,
    ukfpop=as.integer(ukfpop),
    manifesttype=array(manifesttype,dim=length(manifesttype)),
    nobs_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[x!=99999])),dim=nrow(datalong)),
    whichobs_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
      out<-as.numeric(which(x!=99999))
      if(length(out)==0) out<-rep(0,n.manifest)
      if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
      out
    }) ),nrow=c(nrow(datalong),ncol=n.manifest)),
    nbinary_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[manifesttype==1 & x!=99999])),dim=nrow(datalong)),
    whichbinary_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
      out<-as.numeric(which(manifesttype[x!=99999]==1)) #conditional on whichobs
      if(length(out)==0) out<-rep(0,n.manifest)
      if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
      out
    }) ),nrow=c(nrow(datalong),ncol=n.manifest)),
    ncont_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[manifesttype==0 & x!=99999])),dim=nrow(datalong)),
    whichcont_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
      out<-as.numeric(which(manifesttype[x!=99999]==0)) #conditional on whichobs
      if(length(out)==0) out<-rep(0,n.manifest)
      if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
      out
    }) ),nrow=c(nrow(datalong),ncol=n.manifest)))

  if(!is.na(ctstanmodel$stationarymeanprior)) standata$stationarymeanprior=array(ctstanmodel$stationarymeanprior,dim=n.latent)
  if(!is.na(ctstanmodel$stationaryvarprior)) standata$stationaryvarprior=array(ctstanmodel$stationaryvarprior,dim=n.latent)
  
  if(n.TIpred > 0) {
    standata$tipredsdata <- as.matrix(tipreds)
    standata$nmissingtipreds <- length(tipreds[tipreds== 99999])
  }
  
  if(n.TDpred > 0) standata$tdpreds=array(as.matrix(tdpreds),dim=c(nrow(tdpreds),ncol(tdpreds)))
  
  if(fit){
    
    if(!optimize){
    message('Compiling model, ignore forthcoming warning re number of chains...')
    sm <- stan(model_code = c(stanmodeltext),
      data = standata, chains = 0, iter=1, control=list(max_treedepth=1))
    
    #control arguments for rstan
    if(is.null(control$adapt_term_buffer)) control$adapt_term_buffer <- min(c(iter/10,max(iter-20,75)))
    if(is.null(control$adapt_delta)) control$adapt_delta <- .9
    if(is.null(control$adapt_window)) control$adapt_window <- 5
    if(is.null(control$max_treedepth)) control$max_treedepth <- 10
    if(is.null(control$adapt_init_buffer)) adapt_init_buffer=10
    
    
    if(initwithoptim & chains > 0){#optimize with bfgs for initial values
      
      npars=get_num_upars(sm)
      
      if(any(ctspec$indvarying)) popsdindex=(nparams+1):(nparams+ sum(ctspec$indvarying)) else popsdindex<-NULL
      
      lp<-function(parm) {
        parm[popsdindex]<-0
        out<-try(log_prob(sm,upars=parm))
        if(class(out)=='try-error') {
          out=-1e20
        }
        return(out)
      }
      
      grf<-function(parm) {
        parm[popsdindex]<-0
        out=try(grad_log_prob(sm,upars=parm))
                if(class(out)=='try-error') {
          out=rep(-1,length(parm))
        }
        out[popsdindex]=0
        return(out)
      }
      
      message('Optimizing to get inits...')
      optimfit <- stats::optim(stats::rnorm(npars,0,.001), lp, gr=grf, 
        control = list(fnscale = -1,trace=0,parscale=rep(.00001,npars),maxit=2000,factr=1e-12,lmm=100), 
        method='L-BFGS-B',hessian = FALSE)
      parsout=optimfit$par
      parsout[popsdindex]=0
      
      inits=constrain_pars(sm,parsout)
      message('Got inits.')
    }
    
    if(!is.null(inits)){
      staninits=list(inits)
      if(chains > 0){
        for(i in 2:chains){
          staninits[[i]]<-inits
        }
      }
    }
    
    
    if(is.null(inits)){
      staninits=list()
      if(chains > 0){
        for(i in 1:(chains)){
          staninits[[i]]=list(etaupd=array(stats::rnorm(nrow(datalong)*n.latent,0,.1),dim=c(nrow(datalong),n.latent)),
            rawpopsdbase = array(exp(rnorm(nindvarying,-3,1)),dim=c(nindvarying)))
        }
      }
    }
    
    if(cores=='maxneeded') cores=min(c(chains,parallel::detectCores()))
    
    if(!optimize & !vb) {
      message('Sampling...')
      
      stanargs <- list(fit = sm, 
        # enable_random_init=TRUE,
        init_r=.05,
        init=staninits,
        refresh=20,
        iter=iter,
        data = standata, chains = ifelse(optimize==FALSE & vb==FALSE,chains,0), control=control,
        cores=cores,
        ...) 
      
      if(plot==TRUE) stanfit <- do.call(stanWplot,stanargs) else stanfit <- do.call(stan,stanargs)
    }
    }
    
    if(optimize==TRUE && fit==TRUE) {
      
      
      # stanfit <- optimizing(object = stanfit@stanmodel, 
      #   init=0,
      #   # algorithm='BFGS',
      #   as_vector=F,
      #   history_size=6,
      #   init_alpha=.00001,
      #   tol_obj=1e-12, tol_grad=1e-12,tol_param=1e-12,tol_rel_grad=0, tol_rel_obj=0,
      #   data = standata, iter=iter)
      
      # npars=get_num_upars(sm)
      # 
      # if(any(ctspec$indvarying)) popsdindex=(nparams+1):(nparams+ sum(ctspec$indvarying)) else popsdindex<-NULL
      # 
      # lp<-function(parm) {
      #   out<-try(log_prob(sm,upars=parm))
      #   if(class(out)=='try-error'| any(is.nan(out)) | any(is.infinite(out))) {
      #     print(out) 
      #     out=-1e20
      #   }
      #   return(-out)
      # }
      # 
      # grf<-function(parm) {
      #   out=try(grad_log_prob(sm,upars=parm))
      #   if(class(out)=='try-error' | any(is.nan(out)) | any(is.infinite(out))) {
      #     print(out)
      #     out=rnorm(length(parm))
      #   }
      #   return(-out)
      # }
     
      message('Optimizing...')
      # convergence=1
      # iteri=0
      # optimstarts=stats::rnorm(npars,0,.001)
      opt <- stan_model(model_code = stanmodeltext)
      optimfit <- optimizing(opt,standata, hessian=TRUE, iter=40000, init=0,as_vector=FALSE,
        tol_obj=1e-8, tol_rel_obj=0,tol_grad=0,tol_rel_grad=0,tol_param=0,history_size=10)
      
      
      # while(convergence==1){
      #   if(iteri > 0) {
      #     message(paste0('Iteration ', iteri * 500, ', Log prob = ', optimfit$value))
      #     optimstarts=optimfit$par
      #   }
      #   iteri=iteri+1
      #   optimfit <- stats::optim(optimstarts, lp, gr=grf, 
      #     control = list(trace=0,maxit=500,factr=1e5,fnscale=.01,lmm=5), 
      #     method='L-BFGS-B',hessian = TRUE)
      #   convergence=optimfit$convergence
      # }
      

      est=optimfit$par
      sm=suppressMessages(sampling(opt,iter=1,chains=0,data=standata))
      est=unconstrain_pars(sm,est)
      sds=try(sqrt(diag(MASS::ginv(-optimfit$hessian))))  #try(sqrt(diag(solve(optimfit$hessian))))
      if(class(sds)=='try-error') sds <- rep(NA,length(est))
      lest= est - 1.96 * sds
      uest= est + 1.96 * sds
      
      transformedpars=cbind(unlist(constrain_pars(sm,lest)),
        unlist(constrain_pars(sm,est)),
        unlist(constrain_pars(sm,uest)))
      colnames(transformedpars)=c('2.5%','mean','97.5%')
      
      stanfit=list(optimfit=optimfit,transformedpars=transformedpars)
    }
    
    if(vb==TRUE && fit==TRUE) {
      stanfit <- vb(object = sm@stanmodel, 
        iter=iter,
        eta=1e-6,
        data = standata,...)
      
    }
    
    #convert missings back to NA's for data output
    standataout<-unlist(standata)
    standataout[standataout==99999] <- NA
    standataout <- utils::relist(standataout,skeleton=standata)
    
    
    out <- list(args=args,stanmodeltext=stanmodeltext, data=standataout, ctstanmodel=ctstanmodel,stanfit=stanfit)
    class(out) <- 'ctStanFit'
    
  } # end if fit==TRUE
  
  if(!fit) out=list(stanmodeltext=stanmodeltext,data=standata, ctstanmodel=ctstanmodel)
  
  
  return(out)
  }

