% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctStanFit.R
\name{ctStanFit}
\alias{ctStanFit}
\title{ctStanFit}
\usage{
ctStanFit(datalong, ctstanmodelobj, stanmodelobj = NA, iter = 2000,
  kalman = TRUE, binomial = FALSE, fit = TRUE, plot = FALSE,
  adapt_delta = 0.8, max_treedepth = 10, asymdiffusion = FALSE,
  optimize = FALSE, vb = FALSE, chains = 1, inits = NULL,
  initwithoptim = FALSE, ...)
}
\arguments{
\item{datalong}{long format data containing columns for subject id (numeric values, 1 to max subjects), manifest variables, 
any time dependent (i.e. varying within subject) predictors, 
and any time independent (not varying within subject) predictors.}

\item{ctstanmodelobj}{model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt', for continuous or discrete time
models respectively.}

\item{stanmodelobj}{already specified Stan model object, generally leave NA unless modifying Stan model directly.}

\item{iter}{number of iterations, half of which will be devoted to warmup by default.}

\item{kalman}{logical indicating whether or not to integrate over latent states using a Kalman filter. 
Generally recommended to set TRUE unless using non-gaussian measurement model. If not using Kalman filter, experience
suggests that some models / datasets require a relatively high amount of very fast iterations before the sampler is
in the high density region. This can make it difficult to determine the number of iterations needed a priori - in such cases 
setting initwithoptim=TRUE may be helpful.}

\item{binomial}{logical indicating the use of binomial rather than Gaussian data, as with IRT analyses.}

\item{fit}{If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.}

\item{plot}{if TRUE, a Shiny program is launched upon fitting to interactively plot samples. 
May struggle with many (e.g., > 5000) parameters, and may leave sample files in working directory if sampling is terminated.}

\item{adapt_delta}{Stan control parameter denoting acceptance ratio to aim for. Increasing is meant to be useful
as a way to decrease divergent transitions, but I've not observed this for these models.}

\item{max_treedepth}{Stan control parameter, may be worth increasing if many post-warmup iterations reach max treedepth.}

\item{asymdiffusion}{if TRUE, increases fitting speed at cost of model flexibility - T0VAR in the model specification is ignored, the DIFFUSION matrix specification is used as the 
asymptotic DIFFUSION matrix (Q*_inf in the vignette / paper) (making it difficult if not impossible to properly specify
higher order processes). The speed increases come about because the internal Kalman filter routine has many steps removed, and the
asymptotic diffusion parameters are less dependent on the DRIFT matrix.}

\item{optimize}{if TRUE, use Stan's optimizer for maximum a posteriori estimates. Not recommended unless
no parameters vary across subjects.}

\item{vb}{if TRUE, use Stan's variational approximation. Rudimentary testing suggests it is not accurate at present.}

\item{chains}{number of chains to sample.}

\item{inits}{vector of parameter start values, as returned by the rstan function \code{\link{unconstrain_pars}} for instance.}

\item{initwithoptim}{Logical. If TRUE, the model, with population standard deviations fixed to 1 
(so approx 65% of the population mean prior), is first fit with penalised maximum likelihood to determine starting values
for the chains. This can help speed convergence and avoid problematic regions for certain problems.}
}
\description{
Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
Stan.
}
\examples{
\dontrun{
### Single latent process, measured by 1 indicator, 50 subjects, 
### 20 time points, varying intercepts for indicators, single
### time independent predictor.

set.seed(2)

#Specify a ctsem model of type 'omx' for data generation
Tpoints<-20

gm<-ctModel(type='omx', n.latent=1, n.manifest=1, Tpoints=Tpoints,
LAMBDA=diag(1), DRIFT=diag(-.4,1), CINT=diag(0,1),
 MANIFESTMEANS=matrix(0,nrow=1,ncol=1),
 TRAITVAR=diag(1,1),
 n.TIpred=1,
 TIPREDEFFECT = diag(.5,1), TIPREDVAR = diag(2,1),
 MANIFESTVAR=t(chol(diag(.1,1))), DIFFUSION=t(chol(diag(5,1))))

cd<-ctGenerate(gm, n.subjects=50, burnin=300) #generate data

ctIndplot(cd, n.subjects=6, Tpoints=Tpoints, n.manifest=1) #plot a few subjects

#### generate continuous time ctstan model
checkm<-ctModel(type='stanct', n.latent=1, n.manifest=1, LAMBDA=diag(1)) 
 
 #### plot the population priors and some example subject level priors
 ctStanPlotPriors(checkm, wait=FALSE) 
 
 #### Convert ctsem wide format data (used with type = 'omx') 
 #### to appropriate long format
long<-ctWideToLong(cd,Tpoints,n.manifest=checkm$n.manifest,
manifestNames = checkm$manifestNames, n.TDpred=checkm$n.TDpred,
n.TIpred=checkm$n.TIpred, TDpredNames = checkm$TDpredNames,
TIpredNames = checkm$TIpredNames)
  
long<-ctDeintervalise(long) # Convert from time intervals to absolute time

#Set all parameters except the manifest means to be fixed across subjects
checkm$parameters$indvarying[-6]<-FALSE

#Fit the model to the data using 200 iterations, 2 chains and 
#plotting the fit progress.
fit<-ctStanFit(long, checkm, iter=200, chains=2, plot=TRUE)

#traceplot output parameters
traceplot(fit, 
fit@model_pars[grep('output',fit@model_pars)], 
inc_warmup=FALSE) 

#density plot output parameters
stan_dens(fit,c('lp__',
fit@model_pars[grep('output',fit@model_pars)]),
inc_warmup=FALSE) 

s<-summary(fit) #construct summary using stan summary function

#### display rows of summary relevant to output parameters
s$summary[c(grep('output',rownames(s$summary)),grep('lp',rownames(s$summary))),
  c('mean','sd','n_eff','Rhat')] 

####shinystan provides a web gui for exploring the samples
#require(shinystan) 
#launch_shinystan(fit)

#### generate and plot subject specific estimates 
#### for subjects 2 and 3, using the Kalman filter
pred<-ctStanPredictions(ctstanmodelobj=checkm,
ctstanfitobj=fit, subjects=c(2,3), datalong=long)

plot(pred[[2]]$y, type='b', lwd=1, lty=3,col='red')
points(pred[[2]]$ysmooth, type='b', col='red', lwd=2)
points(pred[[3]]$y, type='b', lwd=1, lty=3,col='blue')
points(pred[[3]]$ysmooth, type='b', col='blue', lwd=2)
}
}

